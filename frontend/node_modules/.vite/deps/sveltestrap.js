import "./chunk-AKA55X5Y.js";
import {
  writable
} from "./chunk-FEJRH2TI.js";
import "./chunk-U6PET4NM.js";
import {
  fade
} from "./chunk-FIXQMT7Y.js";
import {
  action,
  add_locations,
  afterUpdate,
  append_styles,
  bind_checked,
  bind_files,
  bind_group,
  bind_select_value,
  bind_this,
  bind_value,
  bind_window_size,
  bubble_event,
  check_target,
  cleanup_styles,
  component,
  createEventDispatcher,
  each,
  handle_lazy_img,
  hmr,
  if_block,
  index,
  init,
  legacy_api,
  legacy_rest_props,
  log_if_contains_state,
  onDestroy,
  onMount,
  prop,
  remove_input_defaults,
  sanitize_slots,
  set_attribute,
  set_attributes,
  set_class,
  set_svg_class,
  setup_stores,
  slot,
  spread_props,
  store_get,
  toggle_class,
  transition,
  validate_store,
  wrap_snippet
} from "./chunk-MG2Z4EBZ.js";
import {
  append,
  comment,
  head,
  preventDefault,
  set_text,
  template,
  text
} from "./chunk-FPYNASPU.js";
import {
  $document,
  $window,
  FILENAME,
  HMR,
  add_owner_effect,
  apply,
  child,
  deep_read_state,
  derived,
  derived_safe_equal,
  effect,
  equals,
  event,
  first_child,
  get,
  getContext,
  invalidate_inner_signals,
  legacy_pre_effect,
  legacy_pre_effect_reset,
  mark_module_end,
  mark_module_start,
  mutable_state,
  mutate,
  next,
  pop,
  push,
  remove_textarea_child,
  replay_events,
  reset,
  set,
  setContext,
  sibling,
  strict_equals,
  template_effect
} from "./chunk-IPX5XGS3.js";
import "./chunk-FVIZKTCK.js";
import "./chunk-EXIRPMAV.js";
import "./chunk-D2QNL2I4.js";
import "./chunk-XSCQBFM2.js";

// ../node_modules/sveltestrap/src/utils.js
function getOriginalBodyPadding() {
  const style = window ? window.getComputedStyle(document.body, null) : {};
  return parseInt(style && style.getPropertyValue("padding-right") || 0, 10);
}
function getScrollbarWidth() {
  let scrollDiv = document.createElement("div");
  scrollDiv.style.position = "absolute";
  scrollDiv.style.top = "-9999px";
  scrollDiv.style.width = "50px";
  scrollDiv.style.height = "50px";
  scrollDiv.style.overflow = "scroll";
  document.body.appendChild(scrollDiv);
  const scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
  document.body.removeChild(scrollDiv);
  return scrollbarWidth;
}
function setScrollbarWidth(padding) {
  document.body.style.paddingRight = padding > 0 ? `${padding}px` : null;
}
function isBodyOverflowing() {
  return window ? document.body.clientWidth < window.innerWidth : false;
}
function isObject(value) {
  const type = typeof value;
  return value != null && (type == "object" || type == "function");
}
function conditionallyUpdateScrollbar() {
  const scrollbarWidth = getScrollbarWidth();
  const fixedContent = document.querySelectorAll(
    ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top"
  )[0];
  const bodyPadding = fixedContent ? parseInt(fixedContent.style.paddingRight || 0, 10) : 0;
  if (isBodyOverflowing()) {
    setScrollbarWidth(bodyPadding + scrollbarWidth);
  }
}
function getColumnSizeClass(isXs, colWidth, colSize) {
  if (colSize === true || colSize === "") {
    return isXs ? "col" : `col-${colWidth}`;
  } else if (colSize === "auto") {
    return isXs ? "col-auto" : `col-${colWidth}-auto`;
  }
  return isXs ? `col-${colSize}` : `col-${colWidth}-${colSize}`;
}
function browserEvent(target, ...args) {
  target.addEventListener(...args);
  return () => target.removeEventListener(...args);
}
function getNewCarouselActiveIndex(direction, items, activeIndex) {
  if (direction === "prev") {
    return activeIndex === 0 ? items.length - 1 : activeIndex - 1;
  } else if (direction === "next") {
    return activeIndex === items.length - 1 ? 0 : activeIndex + 1;
  }
}
function toClassName(value) {
  let result = "";
  if (typeof value === "string" || typeof value === "number") {
    result += value;
  } else if (typeof value === "object") {
    if (Array.isArray(value)) {
      result = value.map(toClassName).filter(Boolean).join(" ");
    } else {
      for (let key in value) {
        if (value[key]) {
          result && (result += " ");
          result += key;
        }
      }
    }
  }
  return result;
}
function classnames(...args) {
  return args.map(toClassName).filter(Boolean).join(" ");
}
function getTransitionDuration(element) {
  if (!element) return 0;
  let { transitionDuration, transitionDelay } = window.getComputedStyle(element);
  const floatTransitionDuration = Number.parseFloat(transitionDuration);
  const floatTransitionDelay = Number.parseFloat(transitionDelay);
  if (!floatTransitionDuration && !floatTransitionDelay) {
    return 0;
  }
  transitionDuration = transitionDuration.split(",")[0];
  transitionDelay = transitionDelay.split(",")[0];
  return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * 1e3;
}
function uuid() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c == "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}

// ../node_modules/sveltestrap/src/Accordion.svelte
mark_module_start();
Accordion[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/Accordion.svelte";
var root = add_locations(template(`<div><!></div>`), Accordion[FILENAME], [[30, 0]]);
function Accordion($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["flush", "stayOpen", "class"]);
  push($$props, false, Accordion);
  const $$stores = setup_stores();
  const $open = () => (validate_store(open, "open"), store_get(open, "$open", $$stores));
  const classes = mutable_state();
  const dispatch = createEventDispatcher();
  let flush = prop($$props, "flush", 8, false);
  let stayOpen = prop($$props, "stayOpen", 8, false);
  let className = prop($$props, "class", 8, "");
  const open = writable();
  setContext("accordion", {
    open,
    stayOpen: stayOpen(),
    toggle: (id) => {
      if (strict_equals($open(), id)) open.set();
      else open.set(id);
      dispatch("toggle", { [id]: strict_equals($open(), id) });
    }
  });
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(flush())),
    () => {
      set(classes, classnames(className(), "accordion", { "accordion-flush": flush() }));
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root();
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  template_effect(() => attributes = set_attributes(div, attributes, { class: get(classes), ...$$restProps }));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Accordion = hmr(Accordion, () => Accordion[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Accordion[HMR].source;
    set(Accordion[HMR].source, module.default[HMR].original);
  });
}
var Accordion_default = Accordion;
mark_module_end(Accordion);

// ../node_modules/sveltestrap/src/AccordionHeader.svelte
mark_module_start();
AccordionHeader[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/AccordionHeader.svelte";
var root2 = add_locations(template(`<h2><button type="button"><!></button></h2>`), AccordionHeader[FILENAME], [[9, 0, [[10, 2]]]]);
function AccordionHeader($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class"]);
  push($$props, false, AccordionHeader);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  legacy_pre_effect(
    () => (classnames, deep_read_state(className())),
    () => {
      set(classes, classnames(className(), "accordion-button"));
    }
  );
  legacy_pre_effect_reset();
  init();
  var h2 = root2();
  let attributes;
  var button = child(h2);
  var node = child(button);
  slot(node, $$props, "default", {}, null);
  reset(button);
  reset(h2);
  template_effect(() => {
    attributes = set_attributes(h2, attributes, { class: "accordion-header", ...$$restProps });
    set_class(button, get(classes));
  });
  event("click", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, h2);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  AccordionHeader = hmr(AccordionHeader, () => AccordionHeader[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AccordionHeader[HMR].source;
    set(AccordionHeader[HMR].source, module.default[HMR].original);
  });
}
var AccordionHeader_default = AccordionHeader;
mark_module_end(AccordionHeader);

// ../node_modules/sveltestrap/src/transitions.js
function backdropIn(node) {
  node.style.display = "block";
  const duration = getTransitionDuration(node);
  return {
    duration,
    tick: (t) => {
      if (t === 0) {
        node.classList.add("show");
      }
    }
  };
}
function backdropOut(node) {
  node.classList.remove("show");
  const duration = getTransitionDuration(node);
  return {
    duration,
    tick: (t) => {
      if (t === 0) {
        node.style.display = "none";
      }
    }
  };
}
function collapseOut(node, params) {
  const dimension = params.horizontal ? "width" : "height";
  node.style[dimension] = `${node.getBoundingClientRect()[dimension]}px`;
  node.classList.add("collapsing");
  node.classList.remove("collapse", "show");
  const duration = getTransitionDuration(node);
  return {
    duration,
    tick: (t) => {
      if (t > 0) {
        node.style[dimension] = "";
      } else if (t === 0) {
        node.classList.remove("collapsing");
        node.classList.add("collapse");
      }
    }
  };
}
function collapseIn(node, params) {
  const horizontal = params.horizontal;
  const dimension = horizontal ? "width" : "height";
  node.classList.add("collapsing");
  node.classList.remove("collapse", "show");
  node.style[dimension] = 0;
  const duration = getTransitionDuration(node);
  return {
    duration,
    tick: (t) => {
      if (t < 1) {
        if (horizontal) {
          node.style.width = `${node.scrollWidth}px`;
        } else {
          node.style.height = `${node.scrollHeight}px`;
        }
      } else {
        node.classList.remove("collapsing");
        node.classList.add("collapse", "show");
        node.style[dimension] = "";
      }
    }
  };
}
function modalIn(node) {
  node.style.display = "block";
  const duration = getTransitionDuration(node);
  return {
    duration,
    tick: (t) => {
      if (t > 0) {
        node.classList.add("show");
      }
    }
  };
}
function modalOut(node) {
  node.classList.remove("show");
  const duration = getTransitionDuration(node);
  return {
    duration,
    tick: (t) => {
      if (t === 1) {
        node.style.display = "none";
      }
    }
  };
}

// ../node_modules/sveltestrap/src/toggle.js
var defaultToggleEvents = ["touchstart", "click"];
var toggle_default = (toggler, togglerFn) => {
  let unbindEvents;
  if (typeof toggler === "string" && typeof window !== "undefined" && document && document.createElement) {
    let selection = document.querySelectorAll(toggler);
    if (!selection.length) {
      selection = document.querySelectorAll(`#${toggler}`);
    }
    if (!selection.length) {
      throw new Error(
        `The target '${toggler}' could not be identified in the dom, tip: check spelling`
      );
    }
    defaultToggleEvents.forEach((event2) => {
      selection.forEach((element) => {
        element.addEventListener(event2, togglerFn);
      });
    });
    unbindEvents = () => {
      defaultToggleEvents.forEach((event2) => {
        selection.forEach((element) => {
          element.removeEventListener(event2, togglerFn);
        });
      });
    };
  }
  return () => {
    if (typeof unbindEvents === "function") {
      unbindEvents();
      unbindEvents = void 0;
    }
  };
};

// ../node_modules/sveltestrap/src/Collapse.svelte
mark_module_start();
Collapse[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/Collapse.svelte";
var root_1 = add_locations(template(`<div><!></div>`), Collapse[FILENAME], [[64, 2]]);
function Collapse($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "isOpen",
    "class",
    "horizontal",
    "navbar",
    "onEntering",
    "onEntered",
    "onExiting",
    "onExited",
    "expand",
    "toggler"
  ]);
  push($$props, false, Collapse);
  const classes = mutable_state();
  const dispatch = createEventDispatcher();
  let isOpen = prop($$props, "isOpen", 12, false);
  let className = prop($$props, "class", 8, "");
  let horizontal = prop($$props, "horizontal", 8, false);
  let navbar = prop($$props, "navbar", 8, false);
  let onEntering = prop($$props, "onEntering", 8, () => dispatch("opening"));
  let onEntered = prop($$props, "onEntered", 8, () => dispatch("open"));
  let onExiting = prop($$props, "onExiting", 8, () => dispatch("closing"));
  let onExited = prop($$props, "onExited", 8, () => dispatch("close"));
  let expand = prop($$props, "expand", 8, false);
  let toggler = prop($$props, "toggler", 8, null);
  onMount(() => toggle_default(toggler(), (e) => {
    isOpen(!isOpen());
    e.preventDefault();
  }));
  let windowWidth = mutable_state(0);
  let _wasMaximized = mutable_state(false);
  const minWidth = mutable_state({});
  mutate(minWidth, get(minWidth)["xs"] = 0);
  mutate(minWidth, get(minWidth)["sm"] = 576);
  mutate(minWidth, get(minWidth)["md"] = 768);
  mutate(minWidth, get(minWidth)["lg"] = 992);
  mutate(minWidth, get(minWidth)["xl"] = 1200);
  function notify() {
    dispatch("update", isOpen());
  }
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(horizontal()), deep_read_state(navbar())),
    () => {
      set(classes, classnames(className(), {
        "collapse-horizontal": horizontal(),
        "navbar-collapse": navbar()
      }));
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(navbar()), deep_read_state(expand()), get(windowWidth), get(minWidth), deep_read_state(isOpen()), get(_wasMaximized)),
    () => {
      if (navbar() && expand()) {
        if (get(windowWidth) >= get(minWidth)[expand()] && !isOpen()) {
          isOpen(true);
          set(_wasMaximized, true);
          notify();
        } else if (get(windowWidth) < get(minWidth)[expand()] && get(_wasMaximized)) {
          isOpen(false);
          set(_wasMaximized, false);
          notify();
        }
      }
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(node, isOpen, ($$anchor2) => {
    var div = root_1();
    let attributes;
    var node_1 = child(div);
    slot(node_1, $$props, "default", {}, null);
    reset(div);
    template_effect(() => attributes = set_attributes(div, attributes, {
      style: navbar() ? void 0 : "overflow: hidden;",
      ...$$restProps,
      class: get(classes)
    }));
    transition(1, div, () => collapseIn, () => ({ horizontal: horizontal() }));
    transition(2, div, () => collapseOut, () => ({ horizontal: horizontal() }));
    event("introstart", div, function($$arg) {
      bubble_event.call(this, $$props, $$arg);
    });
    event("introend", div, function($$arg) {
      bubble_event.call(this, $$props, $$arg);
    });
    event("outrostart", div, function($$arg) {
      bubble_event.call(this, $$props, $$arg);
    });
    event("outroend", div, function($$arg) {
      bubble_event.call(this, $$props, $$arg);
    });
    event("introstart", div, function(...$$args) {
      apply(onEntering, this, $$args, Collapse, [74, 19]);
    });
    event("introend", div, function(...$$args) {
      apply(onEntered, this, $$args, Collapse, [75, 17]);
    });
    event("outrostart", div, function(...$$args) {
      apply(onExiting, this, $$args, Collapse, [76, 19]);
    });
    event("outroend", div, function(...$$args) {
      apply(onExited, this, $$args, Collapse, [77, 17]);
    });
    append($$anchor2, div);
  });
  bind_window_size("innerWidth", ($$value) => set(windowWidth, $$value));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Collapse = hmr(Collapse, () => Collapse[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Collapse[HMR].source;
    set(Collapse[HMR].source, module.default[HMR].original);
  });
}
var Collapse_default = Collapse;
mark_module_end(Collapse);

// ../node_modules/sveltestrap/src/AccordionItem.svelte
mark_module_start();
AccordionItem[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/AccordionItem.svelte";
var root_12 = add_locations(template(`<!> `, 1), AccordionItem[FILENAME], []);
var root_2 = add_locations(template(`<div class="accordion-body"><!></div>`), AccordionItem[FILENAME], [[46, 4]]);
var root3 = add_locations(template(`<div><!> <!></div>`), AccordionItem[FILENAME], [[30, 0]]);
function AccordionItem($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, AccordionItem);
  const $$stores = setup_stores();
  const $open = () => (validate_store(open, "open"), store_get(open, "$open", $$stores));
  const classes = mutable_state();
  const accordionOpen = mutable_state();
  let className = prop($$props, "class", 8, "");
  let header = prop($$props, "header", 8, "");
  let active = prop($$props, "active", 12, false);
  let accordionId = mutable_state();
  const dispatch = createEventDispatcher();
  const { stayOpen, toggle, open } = getContext("accordion");
  onMount(() => {
    if (active()) toggle(get(accordionId));
  });
  const onToggle = () => {
    if (stayOpen) active(!active());
    toggle(get(accordionId));
    dispatch("toggle", !get(accordionOpen));
  };
  legacy_pre_effect(
    () => (classnames, deep_read_state(className())),
    () => {
      set(classes, classnames(className(), "accordion-item"));
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(active()), $open(), get(accordionId)),
    () => {
      set(accordionOpen, stayOpen ? active() : strict_equals($open(), get(accordionId)));
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root3();
  var node = child(div);
  var class_1 = derived_safe_equal(() => !get(accordionOpen) && "collapsed");
  AccordionHeader_default(node, {
    get class() {
      return get(class_1);
    },
    $$events: { click: () => onToggle() },
    children: wrap_snippet(AccordionItem, ($$anchor2, $$slotProps) => {
      var fragment = root_12();
      var node_1 = first_child(fragment);
      slot(node_1, $$props, "header", {}, null);
      var text2 = sibling(node_1);
      template_effect(() => set_text(text2, ` ${header() ?? ""}`));
      append($$anchor2, fragment);
    }),
    $$slots: { default: true }
  });
  var node_2 = sibling(node, 2);
  Collapse_default(node_2, {
    get isOpen() {
      return get(accordionOpen);
    },
    class: "accordion-collapse",
    $$events: {
      introstart($$arg) {
        bubble_event.call(this, $$props, $$arg);
      },
      introend($$arg) {
        bubble_event.call(this, $$props, $$arg);
      },
      outrostart($$arg) {
        bubble_event.call(this, $$props, $$arg);
      },
      outroend($$arg) {
        bubble_event.call(this, $$props, $$arg);
      }
    },
    children: wrap_snippet(AccordionItem, ($$anchor2, $$slotProps) => {
      var div_1 = root_2();
      var node_3 = child(div_1);
      slot(node_3, $$props, "default", {}, null);
      reset(div_1);
      append($$anchor2, div_1);
    }),
    $$slots: { default: true }
  });
  reset(div);
  bind_this(div, ($$value) => set(accordionId, $$value), () => get(accordionId));
  template_effect(() => set_class(div, get(classes)));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  AccordionItem = hmr(AccordionItem, () => AccordionItem[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AccordionItem[HMR].source;
    set(AccordionItem[HMR].source, module.default[HMR].original);
  });
}
var AccordionItem_default = AccordionItem;
mark_module_end(AccordionItem);

// ../node_modules/sveltestrap/src/Alert.svelte
mark_module_start();
Alert[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/Alert.svelte";
var root_22 = add_locations(template(`<h4 class="alert-heading"> <!></h4>`), Alert[FILENAME], [[34, 6]]);
var root_3 = add_locations(template(`<button type="button"></button>`), Alert[FILENAME], [[39, 6]]);
var root_13 = add_locations(template(`<div><!> <!> <!></div>`), Alert[FILENAME], [[27, 2]]);
function Alert($$anchor, $$props) {
  check_target(new.target);
  const $$slots = sanitize_slots($$props);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "class",
    "children",
    "color",
    "closeClassName",
    "closeAriaLabel",
    "dismissible",
    "heading",
    "isOpen",
    "toggle",
    "fade",
    "transition"
  ]);
  push($$props, false, Alert);
  const showClose = mutable_state();
  const handleToggle = mutable_state();
  const classes = mutable_state();
  const closeClassNames = mutable_state();
  let className = prop($$props, "class", 8, "");
  let children = prop($$props, "children", 8, void 0);
  let color = prop($$props, "color", 8, "success");
  let closeClassName = prop($$props, "closeClassName", 8, "");
  let closeAriaLabel = prop($$props, "closeAriaLabel", 8, "Close");
  let dismissible = prop($$props, "dismissible", 8, false);
  let heading = prop($$props, "heading", 8, void 0);
  let isOpen = prop($$props, "isOpen", 12, true);
  let toggle = prop($$props, "toggle", 8, void 0);
  let fade2 = prop($$props, "fade", 8, true);
  let transition2 = prop($$props, "transition", 24, () => ({ duration: fade2() ? 400 : 0 }));
  legacy_pre_effect(
    () => (deep_read_state(dismissible()), deep_read_state(toggle())),
    () => {
      set(showClose, dismissible() || toggle());
    }
  );
  legacy_pre_effect(() => deep_read_state(toggle()), () => {
    set(handleToggle, toggle() || (() => isOpen(false)));
  });
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(color()), get(showClose)),
    () => {
      set(classes, classnames(className(), "alert", `alert-${color()}`, { "alert-dismissible": get(showClose) }));
    }
  );
  legacy_pre_effect(
    () => (classnames, deep_read_state(closeClassName())),
    () => {
      set(closeClassNames, classnames("btn-close", closeClassName()));
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(node, isOpen, ($$anchor2) => {
    var div = root_13();
    let attributes;
    var node_1 = child(div);
    if_block(node_1, () => heading() || $$slots.heading, ($$anchor3) => {
      var h4 = root_22();
      var text2 = child(h4, true);
      var node_2 = sibling(text2);
      slot(node_2, $$props, "heading", {}, null);
      reset(h4);
      template_effect(() => set_text(text2, heading()));
      append($$anchor3, h4);
    });
    var node_3 = sibling(node_1, 2);
    if_block(node_3, () => get(showClose), ($$anchor3) => {
      var button = root_3();
      template_effect(() => {
        set_class(button, get(closeClassNames));
        set_attribute(button, "aria-label", closeAriaLabel());
      });
      event("click", button, function(...$$args) {
        apply(() => get(handleToggle), this, $$args, Alert, [43, 18]);
      });
      append($$anchor3, button);
    });
    var node_4 = sibling(node_3, 2);
    if_block(
      node_4,
      children,
      ($$anchor3) => {
        var text_1 = text();
        template_effect(() => set_text(text_1, children()));
        append($$anchor3, text_1);
      },
      ($$anchor3) => {
        var fragment_2 = comment();
        var node_5 = first_child(fragment_2);
        slot(node_5, $$props, "default", {}, null);
        append($$anchor3, fragment_2);
      }
    );
    reset(div);
    template_effect(() => attributes = set_attributes(div, attributes, {
      ...$$restProps,
      class: get(classes),
      role: "alert"
    }));
    transition(3, div, () => fade, transition2);
    append($$anchor2, div);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Alert = hmr(Alert, () => Alert[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Alert[HMR].source;
    set(Alert[HMR].source, module.default[HMR].original);
  });
}
var Alert_default = Alert;
mark_module_end(Alert);

// ../node_modules/sveltestrap/src/Badge.svelte
mark_module_start();
Badge[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/Badge.svelte";
var root_14 = add_locations(template(`<a><!></a>`), Badge[FILENAME], [[20, 2]]);
var root_4 = add_locations(template(`<span><!></span>`), Badge[FILENAME], [[28, 2]]);
function Badge($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "class",
    "children",
    "color",
    "href",
    "pill"
  ]);
  push($$props, false, Badge);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  let children = prop($$props, "children", 8, void 0);
  let color = prop($$props, "color", 8, "secondary");
  let href = prop($$props, "href", 8, void 0);
  let pill = prop($$props, "pill", 8, false);
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(color()), deep_read_state(pill())),
    () => {
      set(classes, classnames(className(), "badge", `text-bg-${color()}`, pill() ? "rounded-pill" : false));
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    href,
    ($$anchor2) => {
      var a = root_14();
      let attributes;
      var node_1 = child(a);
      if_block(
        node_1,
        children,
        ($$anchor3) => {
          var text2 = text();
          template_effect(() => set_text(text2, children()));
          append($$anchor3, text2);
        },
        ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          slot(node_2, $$props, "default", {}, null);
          append($$anchor3, fragment_2);
        }
      );
      reset(a);
      template_effect(() => attributes = set_attributes(a, attributes, {
        ...$$restProps,
        href: href(),
        class: get(classes)
      }));
      append($$anchor2, a);
    },
    ($$anchor2) => {
      var span = root_4();
      let attributes_1;
      var node_3 = child(span);
      if_block(
        node_3,
        children,
        ($$anchor3) => {
          var text_1 = text();
          template_effect(() => set_text(text_1, children()));
          append($$anchor3, text_1);
        },
        ($$anchor3) => {
          var fragment_4 = comment();
          var node_4 = first_child(fragment_4);
          slot(node_4, $$props, "default", {}, null);
          append($$anchor3, fragment_4);
        }
      );
      reset(span);
      template_effect(() => attributes_1 = set_attributes(span, attributes_1, { ...$$restProps, class: get(classes) }));
      append($$anchor2, span);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Badge = hmr(Badge, () => Badge[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Badge[HMR].source;
    set(Badge[HMR].source, module.default[HMR].original);
  });
}
var Badge_default = Badge;
mark_module_end(Badge);

// ../node_modules/sveltestrap/src/Breadcrumb.svelte
mark_module_start();
Breadcrumb[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/Breadcrumb.svelte";
var root4 = add_locations(template(`<nav><ol><!></ol></nav>`), Breadcrumb[FILENAME], [[17, 0, [[18, 2]]]]);
function Breadcrumb($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "class",
    "children",
    "divider",
    "listClassName",
    "style"
  ]);
  push($$props, false, Breadcrumb);
  const listClasses = mutable_state();
  const styles = mutable_state();
  let className = prop($$props, "class", 8, "");
  let children = prop($$props, "children", 8, void 0);
  let divider = prop($$props, "divider", 8, void 0);
  let listClassName = prop($$props, "listClassName", 8, "");
  let style = prop($$props, "style", 8, void 0);
  legacy_pre_effect(
    () => (classnames, deep_read_state(listClassName())),
    () => {
      set(listClasses, classnames("breadcrumb", listClassName()));
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(divider()), deep_read_state(style())),
    () => {
      set(styles, divider() ? `--bs-breadcrumb-divider: '${divider()}'; ${style() || ""}` : style());
    }
  );
  legacy_pre_effect_reset();
  init();
  var nav = root4();
  let attributes;
  var ol = child(nav);
  var node = child(ol);
  if_block(
    node,
    children,
    ($$anchor2) => {
      var text2 = text();
      template_effect(() => set_text(text2, children()));
      append($$anchor2, text2);
    },
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, $$props, "default", {}, null);
      append($$anchor2, fragment_1);
    }
  );
  reset(ol);
  reset(nav);
  template_effect(() => {
    attributes = set_attributes(nav, attributes, {
      style: get(styles),
      ...$$restProps,
      class: className()
    });
    set_class(ol, get(listClasses));
  });
  append($$anchor, nav);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Breadcrumb = hmr(Breadcrumb, () => Breadcrumb[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Breadcrumb[HMR].source;
    set(Breadcrumb[HMR].source, module.default[HMR].original);
  });
}
var Breadcrumb_default = Breadcrumb;
mark_module_end(Breadcrumb);

// ../node_modules/sveltestrap/src/BreadcrumbItem.svelte
mark_module_start();
BreadcrumbItem[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/BreadcrumbItem.svelte";
var root5 = add_locations(template(`<li><!></li>`), BreadcrumbItem[FILENAME], [[16, 0]]);
function BreadcrumbItem($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class", "active", "children"]);
  push($$props, false, BreadcrumbItem);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  let active = prop($$props, "active", 8, false);
  let children = prop($$props, "children", 8, void 0);
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(active())),
    () => {
      set(classes, classnames(className(), active() ? "active" : false, "breadcrumb-item"));
    }
  );
  legacy_pre_effect_reset();
  init();
  var li = root5();
  let attributes;
  var node = child(li);
  if_block(
    node,
    children,
    ($$anchor2) => {
      var text2 = text();
      template_effect(() => set_text(text2, children()));
      append($$anchor2, text2);
    },
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, $$props, "default", {}, null);
      append($$anchor2, fragment_1);
    }
  );
  reset(li);
  template_effect(() => attributes = set_attributes(li, attributes, {
    ...$$restProps,
    class: get(classes),
    "aria-current": active() ? "page" : void 0
  }));
  append($$anchor, li);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BreadcrumbItem = hmr(BreadcrumbItem, () => BreadcrumbItem[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BreadcrumbItem[HMR].source;
    set(BreadcrumbItem[HMR].source, module.default[HMR].original);
  });
}
var BreadcrumbItem_default = BreadcrumbItem;
mark_module_end(BreadcrumbItem);

// ../node_modules/sveltestrap/src/Button.svelte
mark_module_start();
Button[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/Button.svelte";
var root_15 = add_locations(template(`<a><!></a>`), Button[FILENAME], [[35, 2]]);
var root_42 = add_locations(template(`<button><!></button>`), Button[FILENAME], [[51, 2]]);
function Button($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "class",
    "active",
    "block",
    "children",
    "close",
    "color",
    "disabled",
    "href",
    "inner",
    "outline",
    "size",
    "value"
  ]);
  push($$props, false, Button);
  const ariaLabel = mutable_state();
  const classes = mutable_state();
  const defaultAriaLabel = mutable_state();
  let className = prop($$props, "class", 8, "");
  let active = prop($$props, "active", 8, false);
  let block = prop($$props, "block", 8, false);
  let children = prop($$props, "children", 8, void 0);
  let close = prop($$props, "close", 8, false);
  let color = prop($$props, "color", 8, "secondary");
  let disabled = prop($$props, "disabled", 8, false);
  let href = prop($$props, "href", 8, "");
  let inner = prop($$props, "inner", 12, void 0);
  let outline = prop($$props, "outline", 8, false);
  let size = prop($$props, "size", 8, null);
  let value = prop($$props, "value", 8, "");
  legacy_pre_effect(() => deep_read_state($$sanitized_props), () => {
    set(ariaLabel, $$sanitized_props["aria-label"]);
  });
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(close()), deep_read_state(outline()), deep_read_state(color()), deep_read_state(size()), deep_read_state(block()), deep_read_state(active())),
    () => {
      set(classes, classnames(className(), close() ? "btn-close" : "btn", close() || `btn${outline() ? "-outline" : ""}-${color()}`, size() ? `btn-${size()}` : false, block() ? "d-block w-100" : false, { active: active() }));
    }
  );
  legacy_pre_effect(() => deep_read_state(close()), () => {
    set(defaultAriaLabel, close() ? "Close" : null);
  });
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    href,
    ($$anchor2) => {
      var a = root_15();
      let attributes;
      var node_1 = child(a);
      if_block(
        node_1,
        children,
        ($$anchor3) => {
          var text2 = text();
          template_effect(() => set_text(text2, children()));
          append($$anchor3, text2);
        },
        ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          slot(node_2, $$props, "default", {}, null);
          append($$anchor3, fragment_2);
        }
      );
      reset(a);
      bind_this(a, ($$value) => inner($$value), () => inner());
      template_effect(() => attributes = set_attributes(a, attributes, {
        ...$$restProps,
        class: get(classes),
        disabled: disabled(),
        href: href(),
        "aria-label": get(ariaLabel) || get(defaultAriaLabel)
      }));
      event("click", a, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      append($$anchor2, a);
    },
    ($$anchor2) => {
      var button = root_42();
      let attributes_1;
      var node_3 = child(button);
      slot(node_3, $$props, "default", {}, ($$anchor3) => {
        var fragment_3 = comment();
        var node_4 = first_child(fragment_3);
        if_block(
          node_4,
          children,
          ($$anchor4) => {
            var text_1 = text();
            template_effect(() => set_text(text_1, children()));
            append($$anchor4, text_1);
          },
          ($$anchor4) => {
            var fragment_5 = comment();
            var node_5 = first_child(fragment_5);
            slot(node_5, $$props, "default", {}, null);
            append($$anchor4, fragment_5);
          }
        );
        append($$anchor3, fragment_3);
      });
      reset(button);
      bind_this(button, ($$value) => inner($$value), () => inner());
      template_effect(() => attributes_1 = set_attributes(button, attributes_1, {
        ...$$restProps,
        class: get(classes),
        disabled: disabled(),
        value: value(),
        "aria-label": get(ariaLabel) || get(defaultAriaLabel)
      }));
      event("click", button, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      append($$anchor2, button);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Button = hmr(Button, () => Button[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Button[HMR].source;
    set(Button[HMR].source, module.default[HMR].original);
  });
}
var Button_default = Button;
mark_module_end(Button);

// ../node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// ../node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}

// ../node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// ../node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// ../node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect2,
  requires: ["computeStyles"]
};

// ../node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// ../node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// ../node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// ../node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// ../node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

// ../node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}

// ../node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child2) {
  var rootNode = child2.getRootNode && child2.getRootNode();
  if (parent.contains(child2)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next2 = child2;
    do {
      if (next2 && parent.isSameNode(next2)) {
        return true;
      }
      next2 = next2.parentNode || next2.host;
    } while (next2);
  }
  return false;
}

// ../node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}

// ../node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}

// ../node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}

// ../node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}

// ../node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}

// ../node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// ../node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}

// ../node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// ../node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// ../node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// ../node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect3(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect3,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// ../node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// ../node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x, y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }, getWindow(popper2)) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// ../node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect4(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect4,
  data: {}
};

// ../node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// ../node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// ../node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// ../node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

// ../node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element),
    y
  };
}

// ../node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

// ../node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// ../node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// ../node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}

// ../node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// ../node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// ../node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// ../node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// ../node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}

// ../node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break") break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// ../node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// ../node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// ../node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// ../node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// ../node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// ../node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

// ../node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// ../node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// ../node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// ../node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// ../node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// ../node_modules/@popperjs/core/lib/createPopper.js
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers3 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper4(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers3, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
          if (state.reset === true) {
            state.reset = false;
            index2 = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index2], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect5 = _ref.effect;
        if (typeof effect5 === "function") {
          var cleanupFn = effect5({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var createPopper = popperGenerator();

// ../node_modules/@popperjs/core/lib/popper-lite.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default];
var createPopper2 = popperGenerator({
  defaultModifiers
});

// ../node_modules/@popperjs/core/lib/popper.js
var defaultModifiers2 = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper3 = popperGenerator({
  defaultModifiers: defaultModifiers2
});

// ../node_modules/sveltestrap/src/popper.js
function createPopperActions(initOptions) {
  let contentNode;
  let options = initOptions;
  let popperInstance = null;
  let referenceNode;
  const initPopper = () => {
    if (referenceNode && contentNode) {
      popperInstance = createPopper3(referenceNode, contentNode, options);
    }
  };
  const deinitPopper = () => {
    if (popperInstance) {
      popperInstance.destroy();
      popperInstance = null;
    }
  };
  const referenceAction = (node) => {
    referenceNode = node;
    initPopper();
    return {
      destroy() {
        deinitPopper();
      }
    };
  };
  const contentAction = (node, contentOptions) => {
    contentNode = node;
    options = Object.assign(Object.assign({}, initOptions), contentOptions);
    initPopper();
    return {
      update(newContentOptions) {
        options = Object.assign(
          Object.assign({}, initOptions),
          newContentOptions
        );
        if (popperInstance && options) {
          popperInstance.setOptions(options);
        }
      },
      destroy() {
        deinitPopper();
      }
    };
  };
  return [referenceAction, contentAction, () => popperInstance];
}

// ../node_modules/sveltestrap/src/DropdownContext.js
var createContext = () => writable({});

// ../node_modules/sveltestrap/src/Dropdown.svelte
mark_module_start();
Dropdown[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/Dropdown.svelte";
var root_16 = add_locations(template(`<li><!></li>`), Dropdown[FILENAME], [[124, 2]]);
var root_23 = add_locations(template(`<div><!></div>`), Dropdown[FILENAME], [[128, 2]]);
function Dropdown($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "class",
    "active",
    "autoClose",
    "direction",
    "dropup",
    "group",
    "inNavbar",
    "isOpen",
    "nav",
    "setActiveFromChild",
    "size",
    "toggle"
  ]);
  push($$props, false, Dropdown);
  const subItemIsActive = mutable_state();
  const classes = mutable_state();
  const handleToggle = mutable_state();
  const noop = () => void 0;
  let context = createContext();
  setContext("dropdownContext", context);
  const navbarContext = getContext("navbar");
  let className = prop($$props, "class", 8, "");
  let active = prop($$props, "active", 8, false);
  let autoClose = prop($$props, "autoClose", 8, true);
  let direction = prop($$props, "direction", 8, "down");
  let dropup = prop($$props, "dropup", 8, false);
  let group = prop($$props, "group", 8, false);
  let inNavbar = prop($$props, "inNavbar", 24, () => navbarContext ? navbarContext.inNavbar : false);
  let isOpen = prop($$props, "isOpen", 12, false);
  let nav = prop($$props, "nav", 8, false);
  let setActiveFromChild = prop($$props, "setActiveFromChild", 8, false);
  let size = prop($$props, "size", 8, "");
  let toggle = prop($$props, "toggle", 8, void 0);
  const [popperRef, popperContent] = createPopperActions();
  const validDirections = [
    "up",
    "down",
    "left",
    "right",
    "start",
    "end"
  ];
  if (strict_equals(validDirections.indexOf(direction()), -1)) {
    throw new Error(`Invalid direction sent: '${direction()}' is not one of 'up', 'down', 'left', 'right', 'start', 'end'`);
  }
  let component2 = mutable_state();
  let dropdownDirection = mutable_state();
  function handleDocumentClick(e) {
    if (e && (strict_equals(e.which, 3) || strict_equals(e.type, "keyup") && strict_equals(e.which, 9, false))) return;
    if (get(component2).contains(e.target) && strict_equals(get(component2), e.target, false) && (strict_equals(e.type, "keyup", false) || strict_equals(e.which, 9))) {
      return;
    }
    if (strict_equals(autoClose(), true) || strict_equals(autoClose(), "inside")) {
      get(handleToggle)(e);
    }
  }
  onDestroy(() => {
    if (strict_equals(typeof document, "undefined", false)) {
      ["click", "touchstart", "keyup"].forEach((event2) => document.removeEventListener(event2, handleDocumentClick, true));
    }
  });
  legacy_pre_effect(
    () => (deep_read_state(setActiveFromChild()), get(component2)),
    () => {
      set(subItemIsActive, !!(setActiveFromChild() && get(component2) && strict_equals(typeof get(component2).querySelector, "function") && get(component2).querySelector(".active")));
    }
  );
  legacy_pre_effect(() => deep_read_state(direction()), () => {
    if (strict_equals(direction(), "left")) set(dropdownDirection, "start");
    else if (strict_equals(direction(), "right")) set(dropdownDirection, "end");
    else set(dropdownDirection, direction());
  });
  legacy_pre_effect(
    () => (deep_read_state(toggle()), deep_read_state(isOpen())),
    () => {
      set(handleToggle, toggle() || (() => isOpen(!isOpen())));
    }
  );
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(direction()), get(dropdownDirection), deep_read_state(nav()), deep_read_state(active()), deep_read_state(setActiveFromChild()), get(subItemIsActive), deep_read_state(group()), deep_read_state(size()), deep_read_state(isOpen())),
    () => {
      set(classes, classnames(className(), strict_equals(direction(), "down", false) && `drop${get(dropdownDirection)}`, nav() && active() ? "active" : false, setActiveFromChild() && get(subItemIsActive) ? "active" : false, {
        "btn-group": group(),
        [`btn-group-${size()}`]: !!size(),
        dropdown: !group(),
        show: isOpen(),
        "nav-item": nav()
      }));
    }
  );
  legacy_pre_effect(() => deep_read_state(isOpen()), () => {
    if (strict_equals(typeof document, "undefined", false)) {
      if (isOpen()) {
        ["click", "touchstart", "keyup"].forEach((event2) => document.addEventListener(event2, handleDocumentClick, true));
      } else {
        ["click", "touchstart", "keyup"].forEach((event2) => document.removeEventListener(event2, handleDocumentClick, true));
      }
    }
  });
  legacy_pre_effect(
    () => (get(handleToggle), deep_read_state(isOpen()), deep_read_state(autoClose()), deep_read_state(direction()), deep_read_state(dropup()), deep_read_state(nav()), deep_read_state(inNavbar())),
    () => {
      context.update(() => {
        return {
          toggle: get(handleToggle),
          isOpen: isOpen(),
          autoClose: autoClose(),
          direction: strict_equals(direction(), "down") && dropup() ? "up" : direction(),
          inNavbar: nav() || inNavbar(),
          popperRef: nav() ? noop : popperRef,
          popperContent: nav() ? noop : popperContent
        };
      });
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    nav,
    ($$anchor2) => {
      var li = root_16();
      let attributes;
      var node_1 = child(li);
      slot(node_1, $$props, "default", {}, null);
      reset(li);
      bind_this(li, ($$value) => set(component2, $$value), () => get(component2));
      template_effect(() => attributes = set_attributes(li, attributes, { ...$$restProps, class: get(classes) }));
      append($$anchor2, li);
    },
    ($$anchor2) => {
      var div = root_23();
      let attributes_1;
      var node_2 = child(div);
      slot(node_2, $$props, "default", {}, null);
      reset(div);
      bind_this(div, ($$value) => set(component2, $$value), () => get(component2));
      template_effect(() => attributes_1 = set_attributes(div, attributes_1, { ...$$restProps, class: get(classes) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Dropdown = hmr(Dropdown, () => Dropdown[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Dropdown[HMR].source;
    set(Dropdown[HMR].source, module.default[HMR].original);
  });
}
var Dropdown_default = Dropdown;
mark_module_end(Dropdown);

// ../node_modules/sveltestrap/src/ButtonDropdown.svelte
mark_module_start();
ButtonDropdown[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/ButtonDropdown.svelte";
function ButtonDropdown($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, []);
  push($$props, false, ButtonDropdown);
  var fragment = comment();
  var node = first_child(fragment);
  Dropdown_default(node, spread_props(() => $$restProps, {
    group: true,
    $$events: {
      click($$arg) {
        bubble_event.call(this, $$props, $$arg);
      }
    },
    children: wrap_snippet(ButtonDropdown, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, $$props, "default", {}, null);
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  }));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ButtonDropdown = hmr(ButtonDropdown, () => ButtonDropdown[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ButtonDropdown[HMR].source;
    set(ButtonDropdown[HMR].source, module.default[HMR].original);
  });
}
var ButtonDropdown_default = ButtonDropdown;
mark_module_end(ButtonDropdown);

// ../node_modules/sveltestrap/src/ButtonGroup.svelte
mark_module_start();
ButtonGroup[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/ButtonGroup.svelte";
var root6 = add_locations(template(`<div><!></div>`), ButtonGroup[FILENAME], [[16, 0]]);
function ButtonGroup($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class", "size", "vertical"]);
  push($$props, false, ButtonGroup);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  let size = prop($$props, "size", 8, "");
  let vertical = prop($$props, "vertical", 8, false);
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(size()), deep_read_state(vertical())),
    () => {
      set(classes, classnames(className(), size() ? `btn-group-${size()}` : false, vertical() ? "btn-group-vertical" : "btn-group"));
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root6();
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  template_effect(() => attributes = set_attributes(div, attributes, { ...$$restProps, class: get(classes) }));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ButtonGroup = hmr(ButtonGroup, () => ButtonGroup[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ButtonGroup[HMR].source;
    set(ButtonGroup[HMR].source, module.default[HMR].original);
  });
}
var ButtonGroup_default = ButtonGroup;
mark_module_end(ButtonGroup);

// ../node_modules/sveltestrap/src/ButtonToolbar.svelte
mark_module_start();
ButtonToolbar[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/ButtonToolbar.svelte";
var root7 = add_locations(template(`<div><!></div>`), ButtonToolbar[FILENAME], [[10, 0]]);
function ButtonToolbar($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class"]);
  push($$props, false, ButtonToolbar);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  legacy_pre_effect(
    () => (classnames, deep_read_state(className())),
    () => {
      set(classes, classnames(className(), "btn-toolbar"));
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root7();
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  template_effect(() => attributes = set_attributes(div, attributes, {
    ...$$restProps,
    role: "toolbar",
    class: get(classes)
  }));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ButtonToolbar = hmr(ButtonToolbar, () => ButtonToolbar[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ButtonToolbar[HMR].source;
    set(ButtonToolbar[HMR].source, module.default[HMR].original);
  });
}
var ButtonToolbar_default = ButtonToolbar;
mark_module_end(ButtonToolbar);

// ../node_modules/sveltestrap/src/Card.svelte
mark_module_start();
Card[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/Card.svelte";
var root8 = add_locations(template(`<div><!></div>`), Card[FILENAME], [[21, 0]]);
function Card($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "class",
    "body",
    "color",
    "inverse",
    "outline"
  ]);
  push($$props, false, Card);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  let body = prop($$props, "body", 8, false);
  let color = prop($$props, "color", 8, "");
  let inverse = prop($$props, "inverse", 8, false);
  let outline = prop($$props, "outline", 8, false);
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(inverse()), deep_read_state(body()), deep_read_state(color()), deep_read_state(outline())),
    () => {
      set(classes, classnames(className(), "card", inverse() ? "text-white" : false, body() ? "card-body" : false, color() ? `${outline() ? "border" : "bg"}-${color()}` : false));
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root8();
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  template_effect(() => attributes = set_attributes(div, attributes, { ...$$restProps, class: get(classes) }));
  event("click", div, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Card = hmr(Card, () => Card[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Card[HMR].source;
    set(Card[HMR].source, module.default[HMR].original);
  });
}
var Card_default = Card;
mark_module_end(Card);

// ../node_modules/sveltestrap/src/CardBody.svelte
mark_module_start();
CardBody[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/CardBody.svelte";
var root9 = add_locations(template(`<div><!></div>`), CardBody[FILENAME], [[10, 0]]);
function CardBody($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class"]);
  push($$props, false, CardBody);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  legacy_pre_effect(
    () => (classnames, deep_read_state(className())),
    () => {
      set(classes, classnames(className(), "card-body"));
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root9();
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  template_effect(() => attributes = set_attributes(div, attributes, { ...$$restProps, class: get(classes) }));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CardBody = hmr(CardBody, () => CardBody[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CardBody[HMR].source;
    set(CardBody[HMR].source, module.default[HMR].original);
  });
}
var CardBody_default = CardBody;
mark_module_end(CardBody);

// ../node_modules/sveltestrap/src/CardColumns.svelte
mark_module_start();
CardColumns[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/CardColumns.svelte";
var root10 = add_locations(template(`<div><!></div>`), CardColumns[FILENAME], [[10, 0]]);
function CardColumns($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class"]);
  push($$props, false, CardColumns);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  legacy_pre_effect(
    () => (classnames, deep_read_state(className())),
    () => {
      set(classes, classnames(className(), "card-columns"));
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root10();
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  template_effect(() => attributes = set_attributes(div, attributes, { ...$$restProps, class: get(classes) }));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CardColumns = hmr(CardColumns, () => CardColumns[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CardColumns[HMR].source;
    set(CardColumns[HMR].source, module.default[HMR].original);
  });
}
var CardColumns_default = CardColumns;
mark_module_end(CardColumns);

// ../node_modules/sveltestrap/src/CardDeck.svelte
mark_module_start();
CardDeck[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/CardDeck.svelte";
var root11 = add_locations(template(`<div><!></div>`), CardDeck[FILENAME], [[10, 0]]);
function CardDeck($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class"]);
  push($$props, false, CardDeck);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  legacy_pre_effect(
    () => (classnames, deep_read_state(className())),
    () => {
      set(classes, classnames(className(), "card-deck"));
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root11();
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  template_effect(() => attributes = set_attributes(div, attributes, { ...$$restProps, class: get(classes) }));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CardDeck = hmr(CardDeck, () => CardDeck[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CardDeck[HMR].source;
    set(CardDeck[HMR].source, module.default[HMR].original);
  });
}
var CardDeck_default = CardDeck;
mark_module_end(CardDeck);

// ../node_modules/sveltestrap/src/CardFooter.svelte
mark_module_start();
CardFooter[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/CardFooter.svelte";
var root12 = add_locations(template(`<div><!></div>`), CardFooter[FILENAME], [[10, 0]]);
function CardFooter($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class"]);
  push($$props, false, CardFooter);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  legacy_pre_effect(
    () => (classnames, deep_read_state(className())),
    () => {
      set(classes, classnames(className(), "card-footer"));
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root12();
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  template_effect(() => attributes = set_attributes(div, attributes, { ...$$restProps, class: get(classes) }));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CardFooter = hmr(CardFooter, () => CardFooter[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CardFooter[HMR].source;
    set(CardFooter[HMR].source, module.default[HMR].original);
  });
}
var CardFooter_default = CardFooter;
mark_module_end(CardFooter);

// ../node_modules/sveltestrap/src/CardGroup.svelte
mark_module_start();
CardGroup[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/CardGroup.svelte";
var root13 = add_locations(template(`<div><!></div>`), CardGroup[FILENAME], [[10, 0]]);
function CardGroup($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class"]);
  push($$props, false, CardGroup);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  legacy_pre_effect(
    () => (classnames, deep_read_state(className())),
    () => {
      set(classes, classnames(className(), "card-group"));
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root13();
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  template_effect(() => attributes = set_attributes(div, attributes, { ...$$restProps, class: get(classes) }));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CardGroup = hmr(CardGroup, () => CardGroup[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CardGroup[HMR].source;
    set(CardGroup[HMR].source, module.default[HMR].original);
  });
}
var CardGroup_default = CardGroup;
mark_module_end(CardGroup);

// ../node_modules/sveltestrap/src/CardHeader.svelte
mark_module_start();
CardHeader[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/CardHeader.svelte";
var root_17 = add_locations(template(`<h3><!></h3>`), CardHeader[FILENAME], [[13, 2]]);
var root_24 = add_locations(template(`<div><!></div>`), CardHeader[FILENAME], [[18, 2]]);
function CardHeader($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class", "tag"]);
  push($$props, false, CardHeader);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  let tag = prop($$props, "tag", 8, "div");
  legacy_pre_effect(
    () => (classnames, deep_read_state(className())),
    () => {
      set(classes, classnames(className(), "card-header"));
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => strict_equals(tag(), "h3"),
    ($$anchor2) => {
      var h3 = root_17();
      let attributes;
      var node_1 = child(h3);
      slot(node_1, $$props, "default", {}, null);
      reset(h3);
      template_effect(() => attributes = set_attributes(h3, attributes, { ...$$restProps, class: get(classes) }));
      event("click", h3, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      append($$anchor2, h3);
    },
    ($$anchor2) => {
      var div = root_24();
      let attributes_1;
      var node_2 = child(div);
      slot(node_2, $$props, "default", {}, null);
      reset(div);
      template_effect(() => attributes_1 = set_attributes(div, attributes_1, { ...$$restProps, class: get(classes) }));
      event("click", div, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CardHeader = hmr(CardHeader, () => CardHeader[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CardHeader[HMR].source;
    set(CardHeader[HMR].source, module.default[HMR].original);
  });
}
var CardHeader_default = CardHeader;
mark_module_end(CardHeader);

// ../node_modules/sveltestrap/src/CardImg.svelte
mark_module_start();
CardImg[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/CardImg.svelte";
var root14 = add_locations(template(`<img>`), CardImg[FILENAME], [[24, 0]]);
function CardImg($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class", "top", "bottom", "src", "alt"]);
  push($$props, false, CardImg);
  let className = prop($$props, "class", 8, "");
  let top2 = prop($$props, "top", 8, false);
  let bottom2 = prop($$props, "bottom", 8, false);
  let src = prop($$props, "src", 8);
  let alt = prop($$props, "alt", 8, "");
  let classes = mutable_state("");
  legacy_pre_effect(
    () => (deep_read_state(top2()), deep_read_state(bottom2()), classnames, deep_read_state(className())),
    () => {
      let cardImgClassName = "card-img";
      if (top2()) {
        cardImgClassName = "card-img-top";
      }
      if (bottom2()) {
        cardImgClassName = "card-img-bottom";
      }
      set(classes, classnames(className(), cardImgClassName));
    }
  );
  legacy_pre_effect_reset();
  init();
  var img = root14();
  let attributes;
  template_effect(() => attributes = set_attributes(img, attributes, {
    ...$$restProps,
    class: get(classes),
    src: src(),
    alt: alt()
  }));
  handle_lazy_img(img);
  replay_events(img);
  append($$anchor, img);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CardImg = hmr(CardImg, () => CardImg[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CardImg[HMR].source;
    set(CardImg[HMR].source, module.default[HMR].original);
  });
}
var CardImg_default = CardImg;
mark_module_end(CardImg);

// ../node_modules/sveltestrap/src/CardImgOverlay.svelte
mark_module_start();
CardImgOverlay[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/CardImgOverlay.svelte";
var root15 = add_locations(template(`<div><!></div>`), CardImgOverlay[FILENAME], [[10, 0]]);
function CardImgOverlay($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class"]);
  push($$props, false, CardImgOverlay);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  legacy_pre_effect(
    () => (classnames, deep_read_state(className())),
    () => {
      set(classes, classnames(className(), "card-img-overlay"));
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root15();
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  template_effect(() => attributes = set_attributes(div, attributes, { ...$$restProps, class: get(classes) }));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CardImgOverlay = hmr(CardImgOverlay, () => CardImgOverlay[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CardImgOverlay[HMR].source;
    set(CardImgOverlay[HMR].source, module.default[HMR].original);
  });
}
var CardImgOverlay_default = CardImgOverlay;
mark_module_end(CardImgOverlay);

// ../node_modules/sveltestrap/src/CardLink.svelte
mark_module_start();
CardLink[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/CardLink.svelte";
var root16 = add_locations(template(`<a><!></a>`), CardLink[FILENAME], [[11, 0]]);
function CardLink($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class", "href"]);
  push($$props, false, CardLink);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  let href = prop($$props, "href", 8, "");
  legacy_pre_effect(
    () => (classnames, deep_read_state(className())),
    () => {
      set(classes, classnames(className(), "card-link"));
    }
  );
  legacy_pre_effect_reset();
  init();
  var a = root16();
  let attributes;
  var node = child(a);
  slot(node, $$props, "default", {}, null);
  reset(a);
  template_effect(() => attributes = set_attributes(a, attributes, {
    ...$$restProps,
    class: get(classes),
    href: href()
  }));
  append($$anchor, a);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CardLink = hmr(CardLink, () => CardLink[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CardLink[HMR].source;
    set(CardLink[HMR].source, module.default[HMR].original);
  });
}
var CardLink_default = CardLink;
mark_module_end(CardLink);

// ../node_modules/sveltestrap/src/CardSubtitle.svelte
mark_module_start();
CardSubtitle[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/CardSubtitle.svelte";
var root17 = add_locations(template(`<h6><!></h6>`), CardSubtitle[FILENAME], [[10, 0]]);
function CardSubtitle($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class"]);
  push($$props, false, CardSubtitle);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  legacy_pre_effect(
    () => (classnames, deep_read_state(className())),
    () => {
      set(classes, classnames(className(), "card-subtitle"));
    }
  );
  legacy_pre_effect_reset();
  init();
  var h6 = root17();
  let attributes;
  var node = child(h6);
  slot(node, $$props, "default", {}, null);
  reset(h6);
  template_effect(() => attributes = set_attributes(h6, attributes, { ...$$restProps, class: get(classes) }));
  append($$anchor, h6);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CardSubtitle = hmr(CardSubtitle, () => CardSubtitle[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CardSubtitle[HMR].source;
    set(CardSubtitle[HMR].source, module.default[HMR].original);
  });
}
var CardSubtitle_default = CardSubtitle;
mark_module_end(CardSubtitle);

// ../node_modules/sveltestrap/src/CardText.svelte
mark_module_start();
CardText[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/CardText.svelte";
var root18 = add_locations(template(`<p><!></p>`), CardText[FILENAME], [[10, 0]]);
function CardText($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class"]);
  push($$props, false, CardText);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  legacy_pre_effect(
    () => (classnames, deep_read_state(className())),
    () => {
      set(classes, classnames(className(), "card-text"));
    }
  );
  legacy_pre_effect_reset();
  init();
  var p = root18();
  let attributes;
  var node = child(p);
  slot(node, $$props, "default", {}, null);
  reset(p);
  template_effect(() => attributes = set_attributes(p, attributes, { ...$$restProps, class: get(classes) }));
  append($$anchor, p);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CardText = hmr(CardText, () => CardText[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CardText[HMR].source;
    set(CardText[HMR].source, module.default[HMR].original);
  });
}
var CardText_default = CardText;
mark_module_end(CardText);

// ../node_modules/sveltestrap/src/CardTitle.svelte
mark_module_start();
CardTitle[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/CardTitle.svelte";
var root19 = add_locations(template(`<h5><!></h5>`), CardTitle[FILENAME], [[10, 0]]);
function CardTitle($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class"]);
  push($$props, false, CardTitle);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  legacy_pre_effect(
    () => (classnames, deep_read_state(className())),
    () => {
      set(classes, classnames(className(), "card-title"));
    }
  );
  legacy_pre_effect_reset();
  init();
  var h5 = root19();
  let attributes;
  var node = child(h5);
  slot(node, $$props, "default", {}, null);
  reset(h5);
  template_effect(() => attributes = set_attributes(h5, attributes, { ...$$restProps, class: get(classes) }));
  append($$anchor, h5);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CardTitle = hmr(CardTitle, () => CardTitle[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CardTitle[HMR].source;
    set(CardTitle[HMR].source, module.default[HMR].original);
  });
}
var CardTitle_default = CardTitle;
mark_module_end(CardTitle);

// ../node_modules/sveltestrap/src/Carousel.svelte
mark_module_start();
Carousel[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/Carousel.svelte";
var root20 = add_locations(template(`<div><!></div>`), Carousel[FILENAME], [[85, 0]]);
function Carousel($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "class",
    "items",
    "activeIndex",
    "ride",
    "interval",
    "pause",
    "keyboard"
  ]);
  push($$props, false, Carousel);
  let classes = mutable_state("");
  let className = prop($$props, "class", 8, "");
  let items = prop($$props, "items", 24, () => []);
  let activeIndex = prop($$props, "activeIndex", 12, 0);
  let ride = prop($$props, "ride", 8, true);
  let interval = prop($$props, "interval", 8, 5e3);
  let pause = prop($$props, "pause", 8, true);
  let keyboard = prop($$props, "keyboard", 8, true);
  let _rideTimeoutId = false;
  let _removeVisibilityChangeListener = false;
  onMount(() => {
    setRideTimeout();
    _removeVisibilityChangeListener = browserEvent(document, "visibilitychange", () => {
      if (strict_equals(document.visibilityState, "hidden")) {
        clearRideTimeout();
      } else {
        setRideTimeout();
      }
    });
  });
  onDestroy(() => {
    if (_rideTimeoutId) {
      clearTimeout(_rideTimeoutId);
    }
    if (_removeVisibilityChangeListener) {
      _removeVisibilityChangeListener();
    }
  });
  function handleKeydown(event2) {
    if (!keyboard()) {
      return;
    }
    let direction = "";
    if (strict_equals(event2.key, "ArrowLeft")) {
      direction = "prev";
    } else if (strict_equals(event2.key, "ArrowRight")) {
      direction = "next";
    } else {
      return;
    }
    activeIndex(getNewCarouselActiveIndex(direction, items(), activeIndex()));
  }
  function setRideTimeout() {
    clearRideTimeout();
    if (ride()) {
      _rideTimeoutId = setTimeout(autoNext, interval());
    }
  }
  function clearRideTimeout() {
    if (_rideTimeoutId) {
      clearTimeout(_rideTimeoutId);
    }
  }
  function autoNext() {
    activeIndex(getNewCarouselActiveIndex("next", items(), activeIndex()));
  }
  legacy_pre_effect(
    () => (classnames, deep_read_state(className())),
    () => {
      set(classes, classnames(className(), "carousel", "slide"));
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root20();
  event("keydown", $window, handleKeydown);
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  template_effect(() => attributes = set_attributes(div, attributes, {
    role: "presentation",
    ...$$restProps,
    class: get(classes)
  }));
  event("mouseenter", div, () => pause() ? clearRideTimeout() : void 0);
  event("mouseleave", div, () => pause() ? setRideTimeout() : void 0);
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Carousel = hmr(Carousel, () => Carousel[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Carousel[HMR].source;
    set(Carousel[HMR].source, module.default[HMR].original);
  });
}
var Carousel_default = Carousel;
mark_module_end(Carousel);

// ../node_modules/sveltestrap/src/CarouselCaption.svelte
mark_module_start();
CarouselCaption[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/CarouselCaption.svelte";
var root_18 = add_locations(template(`<h5> </h5>`), CarouselCaption[FILENAME], [[19, 21]]);
var root_25 = add_locations(template(`<p> </p>`), CarouselCaption[FILENAME], [[20, 19]]);
var root21 = add_locations(template(`<div><!> <!> <!></div>`), CarouselCaption[FILENAME], [[18, 0]]);
function CarouselCaption($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class", "captionHeader", "captionText"]);
  push($$props, false, CarouselCaption);
  let classes = mutable_state("");
  let className = prop($$props, "class", 8, "");
  let captionHeader = prop($$props, "captionHeader", 8, "");
  let captionText = prop($$props, "captionText", 8, "");
  legacy_pre_effect(
    () => (classnames, deep_read_state(className())),
    () => {
      set(classes, classnames(className(), "carousel-caption", "d-none", "d-md-block"));
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root21();
  let attributes;
  var node = child(div);
  if_block(node, captionHeader, ($$anchor2) => {
    var h5 = root_18();
    var text2 = child(h5, true);
    reset(h5);
    template_effect(() => set_text(text2, captionHeader()));
    append($$anchor2, h5);
  });
  var node_1 = sibling(node, 2);
  if_block(node_1, captionText, ($$anchor2) => {
    var p = root_25();
    var text_1 = child(p, true);
    reset(p);
    template_effect(() => set_text(text_1, captionText()));
    append($$anchor2, p);
  });
  var node_2 = sibling(node_1, 2);
  slot(node_2, $$props, "default", {}, null);
  reset(div);
  template_effect(() => attributes = set_attributes(div, attributes, { ...$$restProps, class: get(classes) }));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CarouselCaption = hmr(CarouselCaption, () => CarouselCaption[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CarouselCaption[HMR].source;
    set(CarouselCaption[HMR].source, module.default[HMR].original);
  });
}
var CarouselCaption_default = CarouselCaption;
mark_module_end(CarouselCaption);

// ../node_modules/sveltestrap/src/CarouselControl.svelte
mark_module_start();
CarouselControl[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/CarouselControl.svelte";
var root22 = add_locations(template(`<a><span aria-hidden="true"></span> <span class="visually-hidden"> </span></a>`), CarouselControl[FILENAME], [
  [40, 0, [[47, 2], [48, 2]]]
]);
function CarouselControl($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "class",
    "direction",
    "directionText",
    "activeIndex",
    "items",
    "wrap"
  ]);
  push($$props, false, CarouselControl);
  let classes = mutable_state("");
  let className = prop($$props, "class", 8, "");
  let srText = mutable_state("");
  let direction = prop($$props, "direction", 8, "");
  let directionText = prop($$props, "directionText", 8, "");
  let activeIndex = prop($$props, "activeIndex", 12, 0);
  let items = prop($$props, "items", 24, () => []);
  let wrap = prop($$props, "wrap", 8, true);
  const getSrText = (direction2) => {
    if (strict_equals(direction2, "next")) {
      return "Next";
    } else if (strict_equals(direction2, "prev")) {
      return "Previous";
    }
  };
  function clickHandler() {
    const endOrBeginning = strict_equals(direction(), "next") && activeIndex() + 1 > items().length - 1 || strict_equals(direction(), "previous") && activeIndex() - 1 < 0;
    if (!wrap() && endOrBeginning) {
      return;
    }
    activeIndex(getNewCarouselActiveIndex(direction(), items(), activeIndex()));
  }
  legacy_pre_effect(
    () => (classnames, deep_read_state(direction()), deep_read_state(className())),
    () => {
      set(classes, classnames(`carousel-control-${direction()}`, className()));
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(directionText()), deep_read_state(direction())),
    () => {
      set(srText, directionText() ? directionText() : getSrText(direction()));
    }
  );
  legacy_pre_effect_reset();
  init();
  var a = root22();
  let attributes;
  var span = child(a);
  var span_1 = sibling(span, 2);
  var text2 = child(span_1, true);
  reset(span_1);
  reset(a);
  template_effect(() => {
    attributes = set_attributes(a, attributes, {
      ...$$restProps,
      class: get(classes),
      role: "button",
      href: `#${direction() ?? ""}`
    });
    set_class(span, `carousel-control-${direction() ?? ""}-icon`);
    set_text(text2, get(srText));
  });
  event("click", a, preventDefault(clickHandler));
  append($$anchor, a);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CarouselControl = hmr(CarouselControl, () => CarouselControl[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CarouselControl[HMR].source;
    set(CarouselControl[HMR].source, module.default[HMR].original);
  });
}
var CarouselControl_default = CarouselControl;
mark_module_end(CarouselControl);

// ../node_modules/sveltestrap/src/CarouselIndicators.svelte
mark_module_start();
CarouselIndicators[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/CarouselIndicators.svelte";
var root_19 = add_locations(template(`<button data-bs-target=""> </button>`), CarouselIndicators[FILENAME], [[15, 4]]);
var root23 = add_locations(template(`<div></div>`), CarouselIndicators[FILENAME], [[13, 0]]);
function CarouselIndicators($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class", "items", "activeIndex"]);
  push($$props, false, CarouselIndicators);
  let className = prop($$props, "class", 8, "");
  let classes = mutable_state("");
  let items = prop($$props, "items", 24, () => []);
  let activeIndex = prop($$props, "activeIndex", 12, 0);
  legacy_pre_effect(
    () => (classnames, deep_read_state(className())),
    () => {
      set(classes, classnames(className(), "carousel-indicators"));
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root23();
  let attributes;
  each(div, 5, items, index, ($$anchor2, item, index2) => {
    var button = root_19();
    var text2 = child(button, true);
    reset(button);
    template_effect(() => {
      set_attribute(button, "aria-current", strict_equals(activeIndex(), index2));
      set_attribute(button, "aria-label", get(item).title);
      toggle_class(button, "active", strict_equals(activeIndex(), index2));
      set_text(text2, get(item).title ? get(item).title : "");
    });
    event("click", button, () => activeIndex(index2));
    append($$anchor2, button);
  });
  reset(div);
  template_effect(() => attributes = set_attributes(div, attributes, { ...$$restProps, class: get(classes) }));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CarouselIndicators = hmr(CarouselIndicators, () => CarouselIndicators[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CarouselIndicators[HMR].source;
    set(CarouselIndicators[HMR].source, module.default[HMR].original);
  });
}
var CarouselIndicators_default = CarouselIndicators;
mark_module_end(CarouselIndicators);

// ../node_modules/sveltestrap/src/CarouselItem.svelte
mark_module_start();
CarouselItem[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/CarouselItem.svelte";
var root24 = add_locations(template(`<div><!></div>`), CarouselItem[FILENAME], [[13, 0]]);
function CarouselItem($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class", "itemIndex", "activeIndex"]);
  push($$props, false, CarouselItem);
  let classes = mutable_state("");
  let className = prop($$props, "class", 8, "");
  let itemIndex = prop($$props, "itemIndex", 8, 0);
  let activeIndex = prop($$props, "activeIndex", 8, 0);
  legacy_pre_effect(
    () => (classnames, deep_read_state(className())),
    () => {
      set(classes, classnames(className(), "carousel-item"));
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root24();
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, {
      ...$$restProps,
      class: `${get(classes) ?? ""} active`
    });
    toggle_class(div, "active", strict_equals(itemIndex(), activeIndex()));
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CarouselItem = hmr(CarouselItem, () => CarouselItem[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CarouselItem[HMR].source;
    set(CarouselItem[HMR].source, module.default[HMR].original);
  });
}
var CarouselItem_default = CarouselItem;
mark_module_end(CarouselItem);

// ../node_modules/sveltestrap/src/Col.svelte
mark_module_start();
Col[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/Col.svelte";
var root25 = add_locations(template(`<div><!></div>`), Col[FILENAME], [[64, 0]]);
function Col($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "class",
    "xs",
    "sm",
    "md",
    "lg",
    "xl",
    "xxl"
  ]);
  push($$props, false, Col);
  let className = prop($$props, "class", 8, "");
  let xs = prop($$props, "xs", 8, void 0);
  let sm = prop($$props, "sm", 8, void 0);
  let md = prop($$props, "md", 8, void 0);
  let lg = prop($$props, "lg", 8, void 0);
  let xl = prop($$props, "xl", 8, void 0);
  let xxl = prop($$props, "xxl", 8, void 0);
  const colClasses = [];
  const lookup = {
    xs: xs(),
    sm: sm(),
    md: md(),
    lg: lg(),
    xl: xl(),
    xxl: xxl()
  };
  Object.keys(lookup).forEach((colWidth) => {
    const columnProp = lookup[colWidth];
    if (!columnProp && strict_equals(columnProp, "", false)) {
      return;
    }
    const isXs = strict_equals(colWidth, "xs");
    if (isObject(columnProp)) {
      const colSizeInterfix = isXs ? "-" : `-${colWidth}-`;
      const colClass = getColumnSizeClass(isXs, colWidth, columnProp.size);
      if (columnProp.size || strict_equals(columnProp.size, "")) {
        colClasses.push(colClass);
      }
      if (columnProp.push) {
        colClasses.push(`push${colSizeInterfix}${columnProp.push}`);
      }
      if (columnProp.pull) {
        colClasses.push(`pull${colSizeInterfix}${columnProp.pull}`);
      }
      if (columnProp.offset) {
        colClasses.push(`offset${colSizeInterfix}${columnProp.offset}`);
      }
      if (columnProp.order) {
        colClasses.push(`order${colSizeInterfix}${columnProp.order}`);
      }
    } else {
      colClasses.push(getColumnSizeClass(isXs, colWidth, columnProp));
    }
  });
  if (!colClasses.length) {
    colClasses.push("col");
  }
  if (className()) {
    colClasses.push(className());
  }
  init();
  var div = root25();
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  template_effect(() => attributes = set_attributes(div, attributes, {
    ...$$restProps,
    class: colClasses.join(" ")
  }));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Col = hmr(Col, () => Col[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Col[HMR].source;
    set(Col[HMR].source, module.default[HMR].original);
  });
}
var Col_default = Col;
mark_module_end(Col);

// ../node_modules/sveltestrap/src/Column.svelte
mark_module_start();
Column[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/Column.svelte";
var root_110 = add_locations(template(`<col>`), Column[FILENAME], [[16, 2]]);
var root_32 = add_locations(template(`<th><!> <!></th>`), Column[FILENAME], [[18, 2]]);
var root_6 = add_locations(template(`<th><!> <!></th>`), Column[FILENAME], [[23, 2]]);
var root_8 = add_locations(template(`<td><!></td>`), Column[FILENAME], [[28, 2]]);
function Column($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class", "footer", "header", "width"]);
  push($$props, false, Column);
  let className = prop($$props, "class", 8, "");
  let footer = prop($$props, "footer", 8, void 0);
  let header = prop($$props, "header", 8, void 0);
  let width = prop($$props, "width", 8, void 0);
  const colgroup = getContext("colgroup");
  const head2 = getContext("header");
  const foot = getContext("footer");
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => colgroup,
    ($$anchor2) => {
      var col = root_110();
      template_effect(() => set_attribute(col, "style", `width: ${width() ?? ""};`));
      append($$anchor2, col);
    },
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      if_block(
        node_1,
        () => foot,
        ($$anchor3) => {
          var th = root_32();
          let attributes;
          var node_2 = child(th);
          if_block(node_2, footer, ($$anchor4) => {
            var text2 = text();
            template_effect(() => set_text(text2, footer()));
            append($$anchor4, text2);
          });
          var node_3 = sibling(node_2, 2);
          slot(node_3, $$props, "footer", {}, null);
          reset(th);
          template_effect(() => attributes = set_attributes(th, attributes, { ...$$restProps }));
          append($$anchor3, th);
        },
        ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          if_block(
            node_4,
            () => head2,
            ($$anchor4) => {
              var th_1 = root_6();
              let attributes_1;
              var node_5 = child(th_1);
              if_block(node_5, header, ($$anchor5) => {
                var text_1 = text();
                template_effect(() => set_text(text_1, header()));
                append($$anchor5, text_1);
              });
              var node_6 = sibling(node_5, 2);
              slot(node_6, $$props, "header", {}, null);
              reset(th_1);
              template_effect(() => attributes_1 = set_attributes(th_1, attributes_1, { ...$$restProps }));
              append($$anchor4, th_1);
            },
            ($$anchor4) => {
              var td = root_8();
              let attributes_2;
              var node_7 = child(td);
              slot(node_7, $$props, "default", {}, null);
              reset(td);
              template_effect(() => attributes_2 = set_attributes(td, attributes_2, { class: className(), ...$$restProps }));
              append($$anchor4, td);
            },
            true
          );
          append($$anchor3, fragment_3);
        },
        true
      );
      append($$anchor2, fragment_1);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Column = hmr(Column, () => Column[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Column[HMR].source;
    set(Column[HMR].source, module.default[HMR].original);
  });
}
var Column_default = Column;
mark_module_end(Column);

// ../node_modules/sveltestrap/src/Container.svelte
mark_module_start();
Container[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/Container.svelte";
var root26 = add_locations(template(`<div><!></div>`), Container[FILENAME], [[24, 0]]);
function Container($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "class",
    "sm",
    "md",
    "lg",
    "xl",
    "xxl",
    "fluid"
  ]);
  push($$props, false, Container);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  let sm = prop($$props, "sm", 8, void 0);
  let md = prop($$props, "md", 8, void 0);
  let lg = prop($$props, "lg", 8, void 0);
  let xl = prop($$props, "xl", 8, void 0);
  let xxl = prop($$props, "xxl", 8, void 0);
  let fluid = prop($$props, "fluid", 8, false);
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(sm()), deep_read_state(md()), deep_read_state(lg()), deep_read_state(xl()), deep_read_state(xxl()), deep_read_state(fluid())),
    () => {
      set(classes, classnames(className(), {
        "container-sm": sm(),
        "container-md": md(),
        "container-lg": lg(),
        "container-xl": xl(),
        "container-xxl": xxl(),
        "container-fluid": fluid(),
        container: !sm() && !md() && !lg() && !xl() && !xxl() && !fluid()
      }));
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root26();
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  template_effect(() => attributes = set_attributes(div, attributes, { ...$$restProps, class: get(classes) }));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Container = hmr(Container, () => Container[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Container[HMR].source;
    set(Container[HMR].source, module.default[HMR].original);
  });
}
var Container_default = Container;
mark_module_end(Container);

// ../node_modules/sveltestrap/src/DropdownItem.svelte
mark_module_start();
DropdownItem[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/DropdownItem.svelte";
var root_111 = add_locations(template(`<h6><!></h6>`), DropdownItem[FILENAME], [[41, 2]]);
var root_33 = add_locations(template(`<div><!></div>`), DropdownItem[FILENAME], [[46, 2]]);
var root_5 = add_locations(template(`<a><!></a>`), DropdownItem[FILENAME], [[50, 2]]);
var root_62 = add_locations(template(`<button><!></button>`), DropdownItem[FILENAME], [[54, 2]]);
function DropdownItem($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "class",
    "active",
    "disabled",
    "divider",
    "header",
    "toggle",
    "href"
  ]);
  push($$props, false, DropdownItem);
  const $$stores = setup_stores();
  const $context = () => (validate_store(context, "context"), store_get(context, "$context", $$stores));
  const classes = mutable_state();
  const context = getContext("dropdownContext");
  let className = prop($$props, "class", 8, "");
  let active = prop($$props, "active", 8, false);
  let disabled = prop($$props, "disabled", 8, false);
  let divider = prop($$props, "divider", 8, false);
  let header = prop($$props, "header", 8, false);
  let toggle = prop($$props, "toggle", 8, true);
  let href = prop($$props, "href", 8, "");
  function handleItemClick(e) {
    if (disabled() || header() || divider()) {
      e.preventDefault();
      return;
    }
    if (toggle() && (strict_equals($context().autoClose, true) || strict_equals($context().autoClose, "outside"))) {
      $context().toggle(e);
    }
  }
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(disabled()), deep_read_state(divider()), deep_read_state(header()), deep_read_state(active())),
    () => {
      set(classes, classnames(className(), {
        disabled: disabled(),
        "dropdown-item": !divider() && !header(),
        active: active(),
        "dropdown-header": header(),
        "dropdown-divider": divider()
      }));
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    header,
    ($$anchor2) => {
      var h6 = root_111();
      let attributes;
      var node_1 = child(h6);
      slot(node_1, $$props, "default", {}, null);
      reset(h6);
      template_effect(() => attributes = set_attributes(h6, attributes, { ...$$restProps, class: get(classes) }));
      append($$anchor2, h6);
    },
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_2 = first_child(fragment_1);
      if_block(
        node_2,
        divider,
        ($$anchor3) => {
          var div = root_33();
          let attributes_1;
          var node_3 = child(div);
          slot(node_3, $$props, "default", {}, null);
          reset(div);
          template_effect(() => attributes_1 = set_attributes(div, attributes_1, { ...$$restProps, class: get(classes) }));
          event("click", div, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("click", div, handleItemClick);
          append($$anchor3, div);
        },
        ($$anchor3) => {
          var fragment_2 = comment();
          var node_4 = first_child(fragment_2);
          if_block(
            node_4,
            href,
            ($$anchor4) => {
              var a = root_5();
              let attributes_2;
              var node_5 = child(a);
              slot(node_5, $$props, "default", {}, null);
              reset(a);
              template_effect(() => attributes_2 = set_attributes(a, attributes_2, {
                ...$$restProps,
                click: true,
                href: href(),
                class: get(classes)
              }));
              event("click", a, handleItemClick);
              append($$anchor4, a);
            },
            ($$anchor4) => {
              var button = root_62();
              let attributes_3;
              var node_6 = child(button);
              slot(node_6, $$props, "default", {}, null);
              reset(button);
              template_effect(() => attributes_3 = set_attributes(button, attributes_3, {
                type: "button",
                ...$$restProps,
                class: get(classes)
              }));
              event("click", button, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event("click", button, handleItemClick);
              append($$anchor4, button);
            },
            true
          );
          append($$anchor3, fragment_2);
        },
        true
      );
      append($$anchor2, fragment_1);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  DropdownItem = hmr(DropdownItem, () => DropdownItem[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DropdownItem[HMR].source;
    set(DropdownItem[HMR].source, module.default[HMR].original);
  });
}
var DropdownItem_default = DropdownItem;
mark_module_end(DropdownItem);

// ../node_modules/sveltestrap/src/DropdownMenu.svelte
mark_module_start();
DropdownMenu[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/DropdownMenu.svelte";
var root27 = add_locations(template(`<div><!></div>`), DropdownMenu[FILENAME], [[40, 0]]);
function DropdownMenu($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class", "end", "right"]);
  push($$props, false, DropdownMenu);
  const $$stores = setup_stores();
  const $context = () => (validate_store(context, "context"), store_get(context, "$context", $$stores));
  const popperOptions = mutable_state();
  const classes = mutable_state();
  const context = getContext("dropdownContext");
  let className = prop($$props, "class", 8, "");
  let end2 = prop($$props, "end", 8, false);
  let right2 = prop($$props, "right", 8, false);
  const popperPlacement = (direction, end3) => {
    let prefix = direction;
    if (strict_equals(direction, "up")) prefix = "top";
    else if (strict_equals(direction, "down")) prefix = "bottom";
    let suffix = end3 ? "end" : "start";
    return `${prefix}-${suffix}`;
  };
  legacy_pre_effect(
    () => ($context(), deep_read_state(end2()), deep_read_state(right2())),
    () => {
      set(popperOptions, {
        modifiers: [
          { name: "flip" },
          {
            name: "offset",
            options: { offset: [0, 2] }
          }
        ],
        placement: popperPlacement($context().direction, end2() || right2())
      });
    }
  );
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(end2()), deep_read_state(right2()), $context()),
    () => {
      set(classes, classnames(className(), "dropdown-menu", {
        "dropdown-menu-end": end2() || right2(),
        show: $context().isOpen
      }));
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root27();
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  action(div, ($$node, $$action_arg) => $context().popperContent($$node, $$action_arg), () => get(popperOptions));
  template_effect(() => attributes = set_attributes(div, attributes, {
    ...$$restProps,
    class: get(classes),
    "data-bs-popper": $context().inNavbar ? "static" : void 0
  }));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  DropdownMenu = hmr(DropdownMenu, () => DropdownMenu[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DropdownMenu[HMR].source;
    set(DropdownMenu[HMR].source, module.default[HMR].original);
  });
}
var DropdownMenu_default = DropdownMenu;
mark_module_end(DropdownMenu);

// ../node_modules/sveltestrap/src/DropdownToggle.svelte
mark_module_start();
DropdownToggle[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/DropdownToggle.svelte";
var root_26 = add_locations(template(`<span class="visually-hidden"> </span>`), DropdownToggle[FILENAME], [[63, 6]]);
var root_112 = add_locations(template(`<a><!></a>`), DropdownToggle[FILENAME], [[52, 2]]);
var root_52 = add_locations(template(`<span class="visually-hidden"> </span>`), DropdownToggle[FILENAME], [[78, 6]]);
var root_43 = add_locations(template(`<div><!></div>`), DropdownToggle[FILENAME], [[68, 2]]);
var root_82 = add_locations(template(`<span class="visually-hidden"> </span>`), DropdownToggle[FILENAME], [[93, 6]]);
var root_7 = add_locations(template(`<span><!></span>`), DropdownToggle[FILENAME], [[83, 2]]);
var root_10 = add_locations(template(`<span class="visually-hidden"> </span>`), DropdownToggle[FILENAME], [[108, 6]]);
var root_9 = add_locations(template(`<button><!></button>`), DropdownToggle[FILENAME], [[97, 2]]);
function DropdownToggle($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "class",
    "ariaLabel",
    "active",
    "block",
    "caret",
    "color",
    "disabled",
    "inner",
    "nav",
    "outline",
    "size",
    "split",
    "tag"
  ]);
  push($$props, false, DropdownToggle);
  const $$stores = setup_stores();
  const $context = () => (validate_store(context, "context"), store_get(context, "$context", $$stores));
  const classes = mutable_state();
  const btnClasses = mutable_state();
  const context = getContext("dropdownContext");
  let className = prop($$props, "class", 8, "");
  let ariaLabel = prop($$props, "ariaLabel", 8, "Toggle Dropdown");
  let active = prop($$props, "active", 8, false);
  let block = prop($$props, "block", 8, false);
  let caret = prop($$props, "caret", 8, false);
  let color = prop($$props, "color", 8, "secondary");
  let disabled = prop($$props, "disabled", 8, false);
  let inner = prop($$props, "inner", 12, void 0);
  let nav = prop($$props, "nav", 8, false);
  let outline = prop($$props, "outline", 8, false);
  let size = prop($$props, "size", 8, "");
  let split = prop($$props, "split", 8, false);
  let tag = prop($$props, "tag", 8, null);
  function toggleButton(e) {
    if (disabled()) {
      e.preventDefault();
      return;
    }
    if (nav()) {
      e.preventDefault();
    }
    $context().toggle(e);
  }
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(caret()), deep_read_state(split()), deep_read_state(nav())),
    () => {
      set(classes, classnames(className(), {
        "dropdown-toggle": caret() || split(),
        "dropdown-toggle-split": split(),
        "nav-link": nav()
      }));
    }
  );
  legacy_pre_effect(
    () => (classnames, get(classes), deep_read_state(outline()), deep_read_state(color()), deep_read_state(size()), deep_read_state(block()), deep_read_state(active())),
    () => {
      set(btnClasses, classnames(get(classes), "btn", `btn${outline() ? "-outline" : ""}-${color()}`, size() ? `btn-${size()}` : false, block() ? "d-block w-100" : false, { active: active() }));
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    nav,
    ($$anchor2) => {
      var a = root_112();
      let attributes;
      var node_1 = child(a);
      slot(node_1, $$props, "default", {}, ($$anchor3) => {
        var span = root_26();
        var text2 = child(span, true);
        reset(span);
        template_effect(() => set_text(text2, ariaLabel()));
        append($$anchor3, span);
      });
      reset(a);
      action(a, ($$node) => $context().popperRef($$node));
      bind_this(a, ($$value) => inner($$value), () => inner());
      effect(() => event("click", a, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      }));
      effect(() => event("click", a, toggleButton));
      template_effect(() => attributes = set_attributes(a, attributes, {
        ...$$restProps,
        href: "#nav",
        "aria-expanded": $context().isOpen,
        class: get(classes)
      }));
      append($$anchor2, a);
    },
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_2 = first_child(fragment_1);
      if_block(
        node_2,
        () => strict_equals(tag(), "div"),
        ($$anchor3) => {
          var div = root_43();
          let attributes_1;
          var node_3 = child(div);
          slot(node_3, $$props, "default", {}, ($$anchor4) => {
            var span_1 = root_52();
            var text_1 = child(span_1, true);
            reset(span_1);
            template_effect(() => set_text(text_1, ariaLabel()));
            append($$anchor4, span_1);
          });
          reset(div);
          action(div, ($$node) => $context().popperRef($$node));
          bind_this(div, ($$value) => inner($$value), () => inner());
          effect(() => event("click", div, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          }));
          effect(() => event("click", div, toggleButton));
          template_effect(() => attributes_1 = set_attributes(div, attributes_1, {
            ...$$restProps,
            "aria-expanded": $context().isOpen,
            class: get(classes)
          }));
          append($$anchor3, div);
        },
        ($$anchor3) => {
          var fragment_2 = comment();
          var node_4 = first_child(fragment_2);
          if_block(
            node_4,
            () => strict_equals(tag(), "span"),
            ($$anchor4) => {
              var span_2 = root_7();
              let attributes_2;
              var node_5 = child(span_2);
              slot(node_5, $$props, "default", {}, ($$anchor5) => {
                var span_3 = root_82();
                var text_2 = child(span_3, true);
                reset(span_3);
                template_effect(() => set_text(text_2, ariaLabel()));
                append($$anchor5, span_3);
              });
              reset(span_2);
              action(span_2, ($$node) => $context().popperRef($$node));
              bind_this(span_2, ($$value) => inner($$value), () => inner());
              effect(() => event("click", span_2, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              }));
              effect(() => event("click", span_2, toggleButton));
              template_effect(() => attributes_2 = set_attributes(span_2, attributes_2, {
                ...$$restProps,
                "aria-expanded": $context().isOpen,
                class: get(classes)
              }));
              append($$anchor4, span_2);
            },
            ($$anchor4) => {
              var button = root_9();
              let attributes_3;
              var node_6 = child(button);
              slot(node_6, $$props, "default", {}, ($$anchor5) => {
                var span_4 = root_10();
                var text_3 = child(span_4, true);
                reset(span_4);
                template_effect(() => set_text(text_3, ariaLabel()));
                append($$anchor5, span_4);
              });
              reset(button);
              action(button, ($$node) => $context().popperRef($$node));
              bind_this(button, ($$value) => inner($$value), () => inner());
              effect(() => event("click", button, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              }));
              effect(() => event("click", button, toggleButton));
              template_effect(() => attributes_3 = set_attributes(button, attributes_3, {
                ...$$restProps,
                type: "button",
                "aria-expanded": $context().isOpen,
                class: get(btnClasses)
              }));
              append($$anchor4, button);
            },
            true
          );
          append($$anchor3, fragment_2);
        },
        true
      );
      append($$anchor2, fragment_1);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  DropdownToggle = hmr(DropdownToggle, () => DropdownToggle[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DropdownToggle[HMR].source;
    set(DropdownToggle[HMR].source, module.default[HMR].original);
  });
}
var DropdownToggle_default = DropdownToggle;
mark_module_end(DropdownToggle);

// ../node_modules/sveltestrap/src/Fade.svelte
mark_module_start();
Fade[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/Fade.svelte";
var root_113 = add_locations(template(`<div><!></div>`), Fade[FILENAME], [[26, 2]]);
function Fade($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "isOpen",
    "class",
    "onEntering",
    "onEntered",
    "onExiting",
    "onExited",
    "toggler"
  ]);
  push($$props, false, Fade);
  const dispatch = createEventDispatcher();
  let isOpen = prop($$props, "isOpen", 12, false);
  let className = prop($$props, "class", 8, "");
  let onEntering = prop($$props, "onEntering", 8, () => dispatch("opening"));
  let onEntered = prop($$props, "onEntered", 8, () => dispatch("open"));
  let onExiting = prop($$props, "onExiting", 8, () => dispatch("closing"));
  let onExited = prop($$props, "onExited", 8, () => dispatch("close"));
  let toggler = prop($$props, "toggler", 8, null);
  onMount(() => toggle_default(toggler(), (e) => {
    isOpen(!isOpen());
    e.preventDefault();
  }));
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(node, isOpen, ($$anchor2) => {
    var div = root_113();
    let attributes;
    var node_1 = child(div);
    slot(node_1, $$props, "default", {}, null);
    reset(div);
    template_effect(() => attributes = set_attributes(div, attributes, { ...$$restProps, class: className() }));
    transition(3, div, () => fade);
    event("introstart", div, function($$arg) {
      bubble_event.call(this, $$props, $$arg);
    });
    event("introend", div, function($$arg) {
      bubble_event.call(this, $$props, $$arg);
    });
    event("outrostart", div, function($$arg) {
      bubble_event.call(this, $$props, $$arg);
    });
    event("outroend", div, function($$arg) {
      bubble_event.call(this, $$props, $$arg);
    });
    event("introstart", div, function(...$$args) {
      apply(onEntering, this, $$args, Fade, [33, 19]);
    });
    event("introend", div, function(...$$args) {
      apply(onEntered, this, $$args, Fade, [34, 17]);
    });
    event("outrostart", div, function(...$$args) {
      apply(onExiting, this, $$args, Fade, [35, 19]);
    });
    event("outroend", div, function(...$$args) {
      apply(onExited, this, $$args, Fade, [36, 17]);
    });
    append($$anchor2, div);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Fade = hmr(Fade, () => Fade[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Fade[HMR].source;
    set(Fade[HMR].source, module.default[HMR].original);
  });
}
var Fade_default = Fade;
mark_module_end(Fade);

// ../node_modules/sveltestrap/src/Figure.svelte
mark_module_start();
Figure[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/Figure.svelte";
var root_114 = add_locations(template(`<figcaption class="figure-caption"> <!></figcaption>`), Figure[FILENAME], [[20, 4]]);
var root28 = add_locations(template(`<img> <figure><!> <!></figure>`, 1), Figure[FILENAME], [[15, 0], [17, 0]]);
function Figure($$anchor, $$props) {
  check_target(new.target);
  const $$slots = sanitize_slots($$props);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class", "alt", "caption"]);
  push($$props, false, Figure);
  const classes = mutable_state();
  setContext("figure", true);
  let className = prop($$props, "class", 8, "");
  let alt = prop($$props, "alt", 8, void 0);
  let caption = prop($$props, "caption", 8, void 0);
  legacy_pre_effect(
    () => (classnames, deep_read_state(className())),
    () => {
      set(classes, classnames("figure", className()));
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = root28();
  var img = first_child(fragment);
  let attributes;
  var figure = sibling(img, 2);
  let attributes_1;
  var node = child(figure);
  slot(node, $$props, "default", {}, null);
  var node_1 = sibling(node, 2);
  if_block(node_1, () => caption() || $$slots.caption, ($$anchor2) => {
    var figcaption = root_114();
    var text2 = child(figcaption, true);
    var node_2 = sibling(text2);
    slot(node_2, $$props, "caption", {}, null);
    reset(figcaption);
    template_effect(() => set_text(text2, caption()));
    append($$anchor2, figcaption);
  });
  reset(figure);
  template_effect(() => {
    attributes = set_attributes(img, attributes, {
      alt: alt(),
      ...$$restProps,
      class: get(classes)
    });
    attributes_1 = set_attributes(figure, attributes_1, { class: get(classes), ...$$restProps });
  });
  handle_lazy_img(img);
  replay_events(img);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Figure = hmr(Figure, () => Figure[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Figure[HMR].source;
    set(Figure[HMR].source, module.default[HMR].original);
  });
}
var Figure_default = Figure;
mark_module_end(Figure);

// ../node_modules/sveltestrap/src/Form.svelte
mark_module_start();
Form[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/Form.svelte";
var root29 = add_locations(template(`<form><!></form>`), Form[FILENAME], [[15, 0]]);
function Form($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class", "inline", "validated"]);
  push($$props, false, Form);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  let inline = prop($$props, "inline", 8, false);
  let validated = prop($$props, "validated", 8, false);
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(inline()), deep_read_state(validated())),
    () => {
      set(classes, classnames(className(), {
        "form-inline": inline(),
        "was-validated": validated()
      }));
    }
  );
  legacy_pre_effect_reset();
  init();
  var form = root29();
  let attributes;
  var node = child(form);
  slot(node, $$props, "default", {}, null);
  reset(form);
  template_effect(() => attributes = set_attributes(form, attributes, { ...$$restProps, class: get(classes) }));
  event("submit", form, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, form);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Form = hmr(Form, () => Form[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Form[HMR].source;
    set(Form[HMR].source, module.default[HMR].original);
  });
}
var Form_default = Form;
mark_module_end(Form);

// ../node_modules/sveltestrap/src/FormCheck.svelte
mark_module_start();
FormCheck[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/FormCheck.svelte";
var root_115 = add_locations(template(`<input>`), FormCheck[FILENAME], [[37, 4]]);
var root_34 = add_locations(template(`<input>`), FormCheck[FILENAME], [[53, 4]]);
var root_44 = add_locations(template(`<input>`), FormCheck[FILENAME], [[69, 4]]);
var root_53 = add_locations(template(`<label class="form-check-label"><!></label>`), FormCheck[FILENAME], [[86, 4]]);
var root30 = add_locations(template(`<div><!> <!></div>`), FormCheck[FILENAME], [[35, 0]]);
function FormCheck($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "class",
    "checked",
    "disabled",
    "group",
    "id",
    "inline",
    "inner",
    "invalid",
    "label",
    "name",
    "reverse",
    "size",
    "type",
    "valid",
    "value"
  ]);
  push($$props, false, FormCheck);
  const classes = mutable_state();
  const inputClasses = mutable_state();
  const idFor = mutable_state();
  const binding_group = [];
  let className = prop($$props, "class", 8, "");
  let checked = prop($$props, "checked", 12, false);
  let disabled = prop($$props, "disabled", 8, false);
  let group = prop($$props, "group", 12, void 0);
  let id = prop($$props, "id", 8, void 0);
  let inline = prop($$props, "inline", 8, false);
  let inner = prop($$props, "inner", 12, void 0);
  let invalid = prop($$props, "invalid", 8, false);
  let label = prop($$props, "label", 8, "");
  let name = prop($$props, "name", 8, "");
  let reverse = prop($$props, "reverse", 8, false);
  let size = prop($$props, "size", 8, "");
  let type = prop($$props, "type", 8, "checkbox");
  let valid = prop($$props, "valid", 8, false);
  let value = prop($$props, "value", 8, void 0);
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(reverse()), deep_read_state(type()), deep_read_state(inline()), deep_read_state(size())),
    () => {
      set(classes, classnames(className(), "form-check", {
        "form-check-reverse": reverse(),
        "form-switch": strict_equals(type(), "switch"),
        "form-check-inline": inline(),
        [`form-control-${size()}`]: size()
      }));
    }
  );
  legacy_pre_effect(
    () => (classnames, deep_read_state(invalid()), deep_read_state(valid())),
    () => {
      set(inputClasses, classnames("form-check-input", {
        "is-invalid": invalid(),
        "is-valid": valid()
      }));
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(id()), deep_read_state(label())),
    () => {
      set(idFor, id() || label());
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root30();
  var node = child(div);
  if_block(
    node,
    () => strict_equals(type(), "radio"),
    ($$anchor2) => {
      var input = root_115();
      remove_input_defaults(input);
      let attributes;
      bind_this(input, ($$value) => inner($$value), () => inner());
      template_effect(() => attributes = set_attributes(input, attributes, {
        ...$$restProps,
        class: get(inputClasses),
        id: get(idFor),
        type: "radio",
        disabled: disabled(),
        name: name(),
        value: value()
      }));
      event("blur", input, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event("change", input, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event("focus", input, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      event("input", input, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      bind_group(
        binding_group,
        [],
        input,
        () => {
          value();
          return group();
        },
        group
      );
      append($$anchor2, input);
    },
    ($$anchor2) => {
      var fragment = comment();
      var node_1 = first_child(fragment);
      if_block(
        node_1,
        () => strict_equals(type(), "switch"),
        ($$anchor3) => {
          var input_1 = root_34();
          remove_input_defaults(input_1);
          let attributes_1;
          bind_this(input_1, ($$value) => inner($$value), () => inner());
          template_effect(() => attributes_1 = set_attributes(input_1, attributes_1, {
            ...$$restProps,
            class: get(inputClasses),
            id: get(idFor),
            type: "checkbox",
            disabled: disabled(),
            name: name(),
            value: value()
          }));
          event("blur", input_1, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("change", input_1, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("focus", input_1, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("input", input_1, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          bind_checked(input_1, checked);
          append($$anchor3, input_1);
        },
        ($$anchor3) => {
          var input_2 = root_44();
          remove_input_defaults(input_2);
          let attributes_2;
          bind_this(input_2, ($$value) => inner($$value), () => inner());
          template_effect(() => attributes_2 = set_attributes(input_2, attributes_2, {
            ...$$restProps,
            class: get(inputClasses),
            id: get(idFor),
            type: "checkbox",
            disabled: disabled(),
            name: name(),
            value: value()
          }));
          event("blur", input_2, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("change", input_2, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("focus", input_2, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("input", input_2, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          bind_checked(input_2, checked);
          append($$anchor3, input_2);
        },
        true
      );
      append($$anchor2, fragment);
    }
  );
  var node_2 = sibling(node, 2);
  if_block(node_2, label, ($$anchor2) => {
    var label_1 = root_53();
    var node_3 = child(label_1);
    slot(node_3, $$props, "label", {}, ($$anchor3) => {
      var text2 = text();
      template_effect(() => set_text(text2, label()));
      append($$anchor3, text2);
    });
    reset(label_1);
    template_effect(() => set_attribute(label_1, "for", get(idFor)));
    append($$anchor2, label_1);
  });
  reset(div);
  template_effect(() => set_class(div, get(classes)));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FormCheck = hmr(FormCheck, () => FormCheck[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FormCheck[HMR].source;
    set(FormCheck[HMR].source, module.default[HMR].original);
  });
}
var FormCheck_default = FormCheck;
mark_module_end(FormCheck);

// ../node_modules/sveltestrap/src/FormFeedback.svelte
mark_module_start();
FormFeedback[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/FormFeedback.svelte";
var root31 = add_locations(template(`<div><!></div>`), FormFeedback[FILENAME], [[20, 0]]);
function FormFeedback($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class", "valid", "tooltip"]);
  push($$props, false, FormFeedback);
  let className = prop($$props, "class", 8, "");
  let valid = prop($$props, "valid", 8, void 0);
  let tooltip = prop($$props, "tooltip", 8, false);
  let classes = mutable_state();
  legacy_pre_effect(
    () => (deep_read_state(tooltip()), classnames, deep_read_state(className()), deep_read_state(valid())),
    () => {
      const validMode = tooltip() ? "tooltip" : "feedback";
      set(classes, classnames(className(), valid() ? `valid-${validMode}` : `invalid-${validMode}`));
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root31();
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  template_effect(() => attributes = set_attributes(div, attributes, { ...$$restProps, class: get(classes) }));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FormFeedback = hmr(FormFeedback, () => FormFeedback[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FormFeedback[HMR].source;
    set(FormFeedback[HMR].source, module.default[HMR].original);
  });
}
var FormFeedback_default = FormFeedback;
mark_module_end(FormFeedback);

// ../node_modules/sveltestrap/src/FormGroup.svelte
mark_module_start();
FormGroup[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/FormGroup.svelte";
var root_27 = add_locations(template(`<label> <!></label>`), FormGroup[FILENAME], [[28, 6]]);
var root_116 = add_locations(template(`<fieldset><!> <!></fieldset>`), FormGroup[FILENAME], [[24, 2]]);
var root_45 = add_locations(template(`<label> <!></label>`), FormGroup[FILENAME], [[39, 6]]);
var root_35 = add_locations(template(`<div><!> <!></div>`), FormGroup[FILENAME], [[35, 2]]);
function FormGroup($$anchor, $$props) {
  check_target(new.target);
  const $$slots = sanitize_slots($$props);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "class",
    "check",
    "disabled",
    "floating",
    "inline",
    "label",
    "row",
    "tag"
  ]);
  push($$props, false, FormGroup);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  let check = prop($$props, "check", 8, false);
  let disabled = prop($$props, "disabled", 8, false);
  let floating = prop($$props, "floating", 8, false);
  let inline = prop($$props, "inline", 8, false);
  let label = prop($$props, "label", 8, "");
  let row = prop($$props, "row", 8, false);
  let tag = prop($$props, "tag", 8, null);
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(row()), deep_read_state(check()), deep_read_state(inline()), deep_read_state(floating()), deep_read_state(disabled())),
    () => {
      set(classes, classnames(className(), "mb-3", {
        row: row(),
        "form-check": check(),
        "form-check-inline": check() && inline(),
        "form-floating": floating(),
        disabled: check() && disabled()
      }));
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => strict_equals(tag(), "fieldset"),
    ($$anchor2) => {
      var fieldset = root_116();
      let attributes;
      var node_1 = child(fieldset);
      slot(node_1, $$props, "default", {}, null);
      var node_2 = sibling(node_1, 2);
      if_block(node_2, () => label() || $$slots.label, ($$anchor3) => {
        var label_1 = root_27();
        var text2 = child(label_1);
        var node_3 = sibling(text2);
        slot(node_3, $$props, "label", {}, null);
        reset(label_1);
        template_effect(() => set_text(text2, `${label() ?? ""} `));
        append($$anchor3, label_1);
      });
      reset(fieldset);
      template_effect(() => attributes = set_attributes(fieldset, attributes, { ...$$restProps, class: get(classes) }));
      append($$anchor2, fieldset);
    },
    ($$anchor2) => {
      var div = root_35();
      let attributes_1;
      var node_4 = child(div);
      slot(node_4, $$props, "default", {}, null);
      var node_5 = sibling(node_4, 2);
      if_block(node_5, () => label() || $$slots.label, ($$anchor3) => {
        var label_2 = root_45();
        var text_1 = child(label_2);
        var node_6 = sibling(text_1);
        slot(node_6, $$props, "label", {}, null);
        reset(label_2);
        template_effect(() => set_text(text_1, `${label() ?? ""} `));
        append($$anchor3, label_2);
      });
      reset(div);
      template_effect(() => attributes_1 = set_attributes(div, attributes_1, { ...$$restProps, class: get(classes) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FormGroup = hmr(FormGroup, () => FormGroup[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FormGroup[HMR].source;
    set(FormGroup[HMR].source, module.default[HMR].original);
  });
}
var FormGroup_default = FormGroup;
mark_module_end(FormGroup);

// ../node_modules/sveltestrap/src/FormText.svelte
mark_module_start();
FormText[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/FormText.svelte";
var root32 = add_locations(template(`<small><!></small>`), FormText[FILENAME], [[16, 0]]);
function FormText($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class", "inline", "color"]);
  push($$props, false, FormText);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  let inline = prop($$props, "inline", 8, false);
  let color = prop($$props, "color", 8, void 0);
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(inline()), deep_read_state(color())),
    () => {
      set(classes, classnames(className(), !inline() ? "form-text" : false, color() ? `text-${color()}` : false));
    }
  );
  legacy_pre_effect_reset();
  init();
  var small = root32();
  let attributes;
  var node = child(small);
  slot(node, $$props, "default", {}, null);
  reset(small);
  template_effect(() => attributes = set_attributes(small, attributes, { ...$$restProps, class: get(classes) }));
  append($$anchor, small);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FormText = hmr(FormText, () => FormText[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FormText[HMR].source;
    set(FormText[HMR].source, module.default[HMR].original);
  });
}
var FormText_default = FormText;
mark_module_end(FormText);

// ../node_modules/sveltestrap/src/Icon.svelte
mark_module_start();
Icon[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/Icon.svelte";
var root33 = add_locations(template(`<i></i>`), Icon[FILENAME], [[11, 0]]);
function Icon($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class", "name"]);
  push($$props, false, Icon);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  let name = prop($$props, "name", 8, "");
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(name())),
    () => {
      set(classes, classnames(className(), `bi-${name()}`));
    }
  );
  legacy_pre_effect_reset();
  init();
  var i = root33();
  let attributes;
  template_effect(() => attributes = set_attributes(i, attributes, { ...$$restProps, class: get(classes) }));
  append($$anchor, i);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Icon = hmr(Icon, () => Icon[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Icon[HMR].source;
    set(Icon[HMR].source, module.default[HMR].original);
  });
}
var Icon_default = Icon;
mark_module_end(Icon);

// ../node_modules/sveltestrap/src/Image.svelte
mark_module_start();
Image[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/Image.svelte";
var root34 = add_locations(template(`<img>`), Image[FILENAME], [[19, 0]]);
function Image($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "class",
    "alt",
    "figure",
    "fluid",
    "thumbnail"
  ]);
  push($$props, false, Image);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  let alt = prop($$props, "alt", 8, void 0);
  let figure = prop($$props, "figure", 24, () => getContext("figure"));
  let fluid = prop($$props, "fluid", 8, false);
  let thumbnail = prop($$props, "thumbnail", 8, false);
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(figure()), deep_read_state(fluid()), deep_read_state(thumbnail())),
    () => {
      set(classes, classnames(className(), {
        "figure-img": figure(),
        "img-fluid": fluid(),
        "img-thumbnail": thumbnail()
      }));
    }
  );
  legacy_pre_effect_reset();
  init();
  var img = root34();
  let attributes;
  template_effect(() => attributes = set_attributes(img, attributes, {
    alt: alt(),
    ...$$restProps,
    class: get(classes)
  }));
  handle_lazy_img(img);
  replay_events(img);
  append($$anchor, img);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Image = hmr(Image, () => Image[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Image[HMR].source;
    set(Image[HMR].source, module.default[HMR].original);
  });
}
var Image_default = Image;
mark_module_end(Image);

// ../node_modules/sveltestrap/src/InlineContainer.svelte
mark_module_start();
InlineContainer[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/InlineContainer.svelte";
var root35 = add_locations(template(`<div><!></div>`), InlineContainer[FILENAME], [[5, 0]]);
function InlineContainer($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, InlineContainer);
  let x = "wtf svelte?";
  var div = root35();
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  InlineContainer = hmr(InlineContainer, () => InlineContainer[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InlineContainer[HMR].source;
    set(InlineContainer[HMR].source, module.default[HMR].original);
  });
}
var InlineContainer_default = InlineContainer;
mark_module_end(InlineContainer);

// ../node_modules/sveltestrap/src/Input.svelte
mark_module_start();
Input[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/Input.svelte";
var root_28 = add_locations(template(`<input>`), Input[FILENAME], [[96, 4]]);
var root_46 = add_locations(template(`<input>`), Input[FILENAME], [[116, 4]]);
var root_63 = add_locations(template(`<input>`), Input[FILENAME], [[136, 4]]);
var root_83 = add_locations(template(`<input>`), Input[FILENAME], [[155, 4]]);
var root_102 = add_locations(template(`<input>`), Input[FILENAME], [[176, 4]]);
var root_142 = add_locations(template(`<input>`), Input[FILENAME], [[225, 4]]);
var root_162 = add_locations(template(`<input>`), Input[FILENAME], [[245, 4]]);
var root_182 = add_locations(template(`<input>`), Input[FILENAME], [[264, 4]]);
var root_20 = add_locations(template(`<input>`), Input[FILENAME], [[283, 4]]);
var root_222 = add_locations(template(`<input>`), Input[FILENAME], [[302, 4]]);
var root_242 = add_locations(template(`<input>`), Input[FILENAME], [[321, 4]]);
var root_262 = add_locations(template(`<input>`), Input[FILENAME], [[340, 4]]);
var root_282 = add_locations(template(`<input>`), Input[FILENAME], [[359, 4]]);
var root_30 = add_locations(template(`<input>`), Input[FILENAME], [[378, 4]]);
var root_322 = add_locations(template(`<input>`), Input[FILENAME], [[397, 4]]);
var root_342 = add_locations(template(`<input>`), Input[FILENAME], [[417, 4]]);
var root_36 = add_locations(template(`<input>`), Input[FILENAME], [[437, 4]]);
var root_37 = add_locations(template(`<input>`), Input[FILENAME], [[456, 4]]);
var root_39 = add_locations(template(`<textarea></textarea>`), Input[FILENAME], [[475, 2]]);
var root_41 = add_locations(template(`<select><!></select>`), Input[FILENAME], [[493, 2]]);
var root36 = add_locations(template(`<!> <!>`, 1), Input[FILENAME], []);
function Input($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "class",
    "bsSize",
    "checked",
    "color",
    "disabled",
    "feedback",
    "files",
    "group",
    "inner",
    "invalid",
    "label",
    "multiple",
    "name",
    "placeholder",
    "plaintext",
    "readonly",
    "reverse",
    "size",
    "type",
    "valid",
    "value"
  ]);
  push($$props, false, Input);
  const binding_group = [];
  let className = prop($$props, "class", 8, "");
  let bsSize = prop($$props, "bsSize", 12, void 0);
  let checked = prop($$props, "checked", 12, false);
  let color = prop($$props, "color", 8, void 0);
  let disabled = prop($$props, "disabled", 8, void 0);
  let feedback = prop($$props, "feedback", 8, void 0);
  let files = prop($$props, "files", 12, void 0);
  let group = prop($$props, "group", 12, void 0);
  let inner = prop($$props, "inner", 12, void 0);
  let invalid = prop($$props, "invalid", 8, false);
  let label = prop($$props, "label", 8, void 0);
  let multiple = prop($$props, "multiple", 8, void 0);
  let name = prop($$props, "name", 8, "");
  let placeholder = prop($$props, "placeholder", 8, "");
  let plaintext = prop($$props, "plaintext", 8, false);
  let readonly = prop($$props, "readonly", 8, void 0);
  let reverse = prop($$props, "reverse", 8, false);
  let size = prop($$props, "size", 12, void 0);
  let type = prop($$props, "type", 8, "text");
  let valid = prop($$props, "valid", 8, false);
  let value = prop($$props, "value", 12, "");
  let classes = mutable_state();
  let tag = mutable_state();
  const handleInput = (event2) => {
    value(event2.target.value);
  };
  legacy_pre_effect(
    () => (deep_read_state(type()), deep_read_state(color()), deep_read_state(plaintext()), deep_read_state(size()), deep_read_state(bsSize()), classnames, deep_read_state(className()), deep_read_state(invalid()), deep_read_state(valid())),
    () => {
      const isNotaNumber = new RegExp("\\D", "g");
      let isBtn = false;
      let formControlClass = "form-control";
      set(tag, "input");
      switch (type()) {
        case "color":
          formControlClass = `form-control form-control-color`;
          break;
        case "range":
          formControlClass = "form-range";
          break;
        case "select":
          formControlClass = `form-select`;
          set(tag, "select");
          break;
        case "textarea":
          set(tag, "textarea");
          break;
        case "button":
        case "reset":
        case "submit":
          formControlClass = `btn btn-${color() || "secondary"}`;
          isBtn = true;
          break;
        case "hidden":
        case "image":
          formControlClass = void 0;
          break;
        default:
          formControlClass = "form-control";
          set(tag, "input");
      }
      if (plaintext()) {
        formControlClass = `${formControlClass}-plaintext`;
        set(tag, "input");
      }
      if (size() && isNotaNumber.test(size())) {
        console.warn(...log_if_contains_state("warn", `Please use the prop "bsSize" instead of the "size" to bootstrap's input sizing.`));
        bsSize(size());
        size(void 0);
      }
      set(classes, classnames(className(), formControlClass, {
        "is-invalid": invalid(),
        "is-valid": valid(),
        [`form-control-${bsSize()}`]: bsSize() && !isBtn,
        [`btn-${bsSize()}`]: bsSize() && isBtn
      }));
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = root36();
  var node = first_child(fragment);
  if_block(
    node,
    () => strict_equals(get(tag), "input"),
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      if_block(
        node_1,
        () => strict_equals(type(), "text"),
        ($$anchor3) => {
          var input = root_28();
          remove_input_defaults(input);
          let attributes;
          bind_this(input, ($$value) => inner($$value), () => inner());
          template_effect(() => attributes = set_attributes(input, attributes, {
            ...$$restProps,
            class: get(classes),
            type: "text",
            disabled: disabled(),
            name: name(),
            placeholder: placeholder(),
            readonly: readonly(),
            size: size()
          }));
          event("blur", input, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("change", input, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("focus", input, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("input", input, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("keydown", input, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("keypress", input, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("keyup", input, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          bind_value(input, value);
          append($$anchor3, input);
        },
        ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          if_block(
            node_2,
            () => strict_equals(type(), "password"),
            ($$anchor4) => {
              var input_1 = root_46();
              remove_input_defaults(input_1);
              let attributes_1;
              bind_this(input_1, ($$value) => inner($$value), () => inner());
              template_effect(() => attributes_1 = set_attributes(input_1, attributes_1, {
                ...$$restProps,
                class: get(classes),
                type: "password",
                disabled: disabled(),
                name: name(),
                placeholder: placeholder(),
                readonly: readonly(),
                size: size()
              }));
              event("blur", input_1, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event("change", input_1, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event("focus", input_1, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event("input", input_1, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event("keydown", input_1, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event("keypress", input_1, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event("keyup", input_1, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              bind_value(input_1, value);
              append($$anchor4, input_1);
            },
            ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              if_block(
                node_3,
                () => strict_equals(type(), "color"),
                ($$anchor5) => {
                  var input_2 = root_63();
                  remove_input_defaults(input_2);
                  let attributes_2;
                  bind_this(input_2, ($$value) => inner($$value), () => inner());
                  template_effect(() => attributes_2 = set_attributes(input_2, attributes_2, {
                    ...$$restProps,
                    class: get(classes),
                    type: "color",
                    disabled: disabled(),
                    name: name(),
                    placeholder: placeholder(),
                    readonly: readonly()
                  }));
                  event("blur", input_2, function($$arg) {
                    bubble_event.call(this, $$props, $$arg);
                  });
                  event("change", input_2, function($$arg) {
                    bubble_event.call(this, $$props, $$arg);
                  });
                  event("focus", input_2, function($$arg) {
                    bubble_event.call(this, $$props, $$arg);
                  });
                  event("input", input_2, function($$arg) {
                    bubble_event.call(this, $$props, $$arg);
                  });
                  event("keydown", input_2, function($$arg) {
                    bubble_event.call(this, $$props, $$arg);
                  });
                  event("keypress", input_2, function($$arg) {
                    bubble_event.call(this, $$props, $$arg);
                  });
                  event("keyup", input_2, function($$arg) {
                    bubble_event.call(this, $$props, $$arg);
                  });
                  bind_value(input_2, value);
                  append($$anchor5, input_2);
                },
                ($$anchor5) => {
                  var fragment_4 = comment();
                  var node_4 = first_child(fragment_4);
                  if_block(
                    node_4,
                    () => strict_equals(type(), "email"),
                    ($$anchor6) => {
                      var input_3 = root_83();
                      remove_input_defaults(input_3);
                      let attributes_3;
                      bind_this(input_3, ($$value) => inner($$value), () => inner());
                      template_effect(() => attributes_3 = set_attributes(input_3, attributes_3, {
                        ...$$restProps,
                        class: get(classes),
                        type: "email",
                        disabled: disabled(),
                        multiple: multiple(),
                        name: name(),
                        placeholder: placeholder(),
                        readonly: readonly(),
                        size: size()
                      }));
                      event("blur", input_3, function($$arg) {
                        bubble_event.call(this, $$props, $$arg);
                      });
                      event("change", input_3, function($$arg) {
                        bubble_event.call(this, $$props, $$arg);
                      });
                      event("focus", input_3, function($$arg) {
                        bubble_event.call(this, $$props, $$arg);
                      });
                      event("input", input_3, function($$arg) {
                        bubble_event.call(this, $$props, $$arg);
                      });
                      event("keydown", input_3, function($$arg) {
                        bubble_event.call(this, $$props, $$arg);
                      });
                      event("keypress", input_3, function($$arg) {
                        bubble_event.call(this, $$props, $$arg);
                      });
                      event("keyup", input_3, function($$arg) {
                        bubble_event.call(this, $$props, $$arg);
                      });
                      bind_value(input_3, value);
                      append($$anchor6, input_3);
                    },
                    ($$anchor6) => {
                      var fragment_5 = comment();
                      var node_5 = first_child(fragment_5);
                      if_block(
                        node_5,
                        () => strict_equals(type(), "file"),
                        ($$anchor7) => {
                          var input_4 = root_102();
                          remove_input_defaults(input_4);
                          let attributes_4;
                          bind_this(input_4, ($$value) => inner($$value), () => inner());
                          template_effect(() => attributes_4 = set_attributes(input_4, attributes_4, {
                            ...$$restProps,
                            class: get(classes),
                            type: "file",
                            disabled: disabled(),
                            invalid: invalid(),
                            multiple: multiple(),
                            name: name(),
                            placeholder: placeholder(),
                            readonly: readonly(),
                            valid: valid()
                          }));
                          event("blur", input_4, function($$arg) {
                            bubble_event.call(this, $$props, $$arg);
                          });
                          event("change", input_4, function($$arg) {
                            bubble_event.call(this, $$props, $$arg);
                          });
                          event("focus", input_4, function($$arg) {
                            bubble_event.call(this, $$props, $$arg);
                          });
                          event("input", input_4, function($$arg) {
                            bubble_event.call(this, $$props, $$arg);
                          });
                          event("keydown", input_4, function($$arg) {
                            bubble_event.call(this, $$props, $$arg);
                          });
                          event("keypress", input_4, function($$arg) {
                            bubble_event.call(this, $$props, $$arg);
                          });
                          event("keyup", input_4, function($$arg) {
                            bubble_event.call(this, $$props, $$arg);
                          });
                          bind_files(input_4, files);
                          bind_value(input_4, value);
                          append($$anchor7, input_4);
                        },
                        ($$anchor7) => {
                          var fragment_6 = comment();
                          var node_6 = first_child(fragment_6);
                          if_block(
                            node_6,
                            () => strict_equals(type(), "checkbox") || strict_equals(type(), "radio") || strict_equals(type(), "switch"),
                            ($$anchor8) => {
                              var fragment_7 = comment();
                              var node_7 = first_child(fragment_7);
                              {
                                add_owner_effect(checked, FormCheck_default);
                                add_owner_effect(inner, FormCheck_default);
                                add_owner_effect(group, FormCheck_default);
                                add_owner_effect(value, FormCheck_default);
                                FormCheck_default(node_7, spread_props(() => $$restProps, {
                                  get class() {
                                    return className();
                                  },
                                  get size() {
                                    return bsSize();
                                  },
                                  get type() {
                                    return type();
                                  },
                                  get checked() {
                                    return checked();
                                  },
                                  set checked($$value) {
                                    checked($$value);
                                  },
                                  get inner() {
                                    return inner();
                                  },
                                  set inner($$value) {
                                    inner($$value);
                                  },
                                  get group() {
                                    return group();
                                  },
                                  set group($$value) {
                                    group($$value);
                                  },
                                  get value() {
                                    return value();
                                  },
                                  set value($$value) {
                                    value($$value);
                                  },
                                  get disabled() {
                                    return disabled();
                                  },
                                  get invalid() {
                                    return invalid();
                                  },
                                  get label() {
                                    return label();
                                  },
                                  get name() {
                                    return name();
                                  },
                                  get placeholder() {
                                    return placeholder();
                                  },
                                  get reverse() {
                                    return reverse();
                                  },
                                  get readonly() {
                                    return readonly();
                                  },
                                  get valid() {
                                    return valid();
                                  },
                                  $$events: {
                                    blur($$arg) {
                                      bubble_event.call(this, $$props, $$arg);
                                    },
                                    change($$arg) {
                                      bubble_event.call(this, $$props, $$arg);
                                    },
                                    focus($$arg) {
                                      bubble_event.call(this, $$props, $$arg);
                                    },
                                    input($$arg) {
                                      bubble_event.call(this, $$props, $$arg);
                                    },
                                    keydown($$arg) {
                                      bubble_event.call(this, $$props, $$arg);
                                    },
                                    keypress($$arg) {
                                      bubble_event.call(this, $$props, $$arg);
                                    },
                                    keyup($$arg) {
                                      bubble_event.call(this, $$props, $$arg);
                                    }
                                  },
                                  $$legacy: true
                                }));
                              }
                              append($$anchor8, fragment_7);
                            },
                            ($$anchor8) => {
                              var fragment_8 = comment();
                              var node_8 = first_child(fragment_8);
                              if_block(
                                node_8,
                                () => strict_equals(type(), "url"),
                                ($$anchor9) => {
                                  var input_5 = root_142();
                                  remove_input_defaults(input_5);
                                  let attributes_5;
                                  bind_this(input_5, ($$value) => inner($$value), () => inner());
                                  template_effect(() => attributes_5 = set_attributes(input_5, attributes_5, {
                                    ...$$restProps,
                                    class: get(classes),
                                    type: "url",
                                    disabled: disabled(),
                                    name: name(),
                                    placeholder: placeholder(),
                                    readonly: readonly(),
                                    size: size()
                                  }));
                                  event("blur", input_5, function($$arg) {
                                    bubble_event.call(this, $$props, $$arg);
                                  });
                                  event("change", input_5, function($$arg) {
                                    bubble_event.call(this, $$props, $$arg);
                                  });
                                  event("focus", input_5, function($$arg) {
                                    bubble_event.call(this, $$props, $$arg);
                                  });
                                  event("input", input_5, function($$arg) {
                                    bubble_event.call(this, $$props, $$arg);
                                  });
                                  event("keydown", input_5, function($$arg) {
                                    bubble_event.call(this, $$props, $$arg);
                                  });
                                  event("keypress", input_5, function($$arg) {
                                    bubble_event.call(this, $$props, $$arg);
                                  });
                                  event("keyup", input_5, function($$arg) {
                                    bubble_event.call(this, $$props, $$arg);
                                  });
                                  bind_value(input_5, value);
                                  append($$anchor9, input_5);
                                },
                                ($$anchor9) => {
                                  var fragment_9 = comment();
                                  var node_9 = first_child(fragment_9);
                                  if_block(
                                    node_9,
                                    () => strict_equals(type(), "number"),
                                    ($$anchor10) => {
                                      var input_6 = root_162();
                                      remove_input_defaults(input_6);
                                      let attributes_6;
                                      bind_this(input_6, ($$value) => inner($$value), () => inner());
                                      template_effect(() => attributes_6 = set_attributes(input_6, attributes_6, {
                                        ...$$restProps,
                                        class: get(classes),
                                        type: "number",
                                        readonly: readonly(),
                                        name: name(),
                                        disabled: disabled(),
                                        placeholder: placeholder()
                                      }));
                                      event("blur", input_6, function($$arg) {
                                        bubble_event.call(this, $$props, $$arg);
                                      });
                                      event("change", input_6, function($$arg) {
                                        bubble_event.call(this, $$props, $$arg);
                                      });
                                      event("focus", input_6, function($$arg) {
                                        bubble_event.call(this, $$props, $$arg);
                                      });
                                      event("input", input_6, function($$arg) {
                                        bubble_event.call(this, $$props, $$arg);
                                      });
                                      event("keydown", input_6, function($$arg) {
                                        bubble_event.call(this, $$props, $$arg);
                                      });
                                      event("keypress", input_6, function($$arg) {
                                        bubble_event.call(this, $$props, $$arg);
                                      });
                                      event("keyup", input_6, function($$arg) {
                                        bubble_event.call(this, $$props, $$arg);
                                      });
                                      bind_value(input_6, value);
                                      append($$anchor10, input_6);
                                    },
                                    ($$anchor10) => {
                                      var fragment_10 = comment();
                                      var node_10 = first_child(fragment_10);
                                      if_block(
                                        node_10,
                                        () => strict_equals(type(), "date"),
                                        ($$anchor11) => {
                                          var input_7 = root_182();
                                          remove_input_defaults(input_7);
                                          let attributes_7;
                                          bind_this(input_7, ($$value) => inner($$value), () => inner());
                                          template_effect(() => attributes_7 = set_attributes(input_7, attributes_7, {
                                            ...$$restProps,
                                            class: get(classes),
                                            type: "date",
                                            disabled: disabled(),
                                            name: name(),
                                            placeholder: placeholder(),
                                            readonly: readonly()
                                          }));
                                          event("blur", input_7, function($$arg) {
                                            bubble_event.call(this, $$props, $$arg);
                                          });
                                          event("change", input_7, function($$arg) {
                                            bubble_event.call(this, $$props, $$arg);
                                          });
                                          event("focus", input_7, function($$arg) {
                                            bubble_event.call(this, $$props, $$arg);
                                          });
                                          event("input", input_7, function($$arg) {
                                            bubble_event.call(this, $$props, $$arg);
                                          });
                                          event("keydown", input_7, function($$arg) {
                                            bubble_event.call(this, $$props, $$arg);
                                          });
                                          event("keypress", input_7, function($$arg) {
                                            bubble_event.call(this, $$props, $$arg);
                                          });
                                          event("keyup", input_7, function($$arg) {
                                            bubble_event.call(this, $$props, $$arg);
                                          });
                                          bind_value(input_7, value);
                                          append($$anchor11, input_7);
                                        },
                                        ($$anchor11) => {
                                          var fragment_11 = comment();
                                          var node_11 = first_child(fragment_11);
                                          if_block(
                                            node_11,
                                            () => strict_equals(type(), "time"),
                                            ($$anchor12) => {
                                              var input_8 = root_20();
                                              remove_input_defaults(input_8);
                                              let attributes_8;
                                              bind_this(input_8, ($$value) => inner($$value), () => inner());
                                              template_effect(() => attributes_8 = set_attributes(input_8, attributes_8, {
                                                ...$$restProps,
                                                class: get(classes),
                                                type: "time",
                                                disabled: disabled(),
                                                name: name(),
                                                placeholder: placeholder(),
                                                readonly: readonly()
                                              }));
                                              event("blur", input_8, function($$arg) {
                                                bubble_event.call(this, $$props, $$arg);
                                              });
                                              event("change", input_8, function($$arg) {
                                                bubble_event.call(this, $$props, $$arg);
                                              });
                                              event("focus", input_8, function($$arg) {
                                                bubble_event.call(this, $$props, $$arg);
                                              });
                                              event("input", input_8, function($$arg) {
                                                bubble_event.call(this, $$props, $$arg);
                                              });
                                              event("keydown", input_8, function($$arg) {
                                                bubble_event.call(this, $$props, $$arg);
                                              });
                                              event("keypress", input_8, function($$arg) {
                                                bubble_event.call(this, $$props, $$arg);
                                              });
                                              event("keyup", input_8, function($$arg) {
                                                bubble_event.call(this, $$props, $$arg);
                                              });
                                              bind_value(input_8, value);
                                              append($$anchor12, input_8);
                                            },
                                            ($$anchor12) => {
                                              var fragment_12 = comment();
                                              var node_12 = first_child(fragment_12);
                                              if_block(
                                                node_12,
                                                () => strict_equals(type(), "datetime"),
                                                ($$anchor13) => {
                                                  var input_9 = root_222();
                                                  remove_input_defaults(input_9);
                                                  let attributes_9;
                                                  bind_this(input_9, ($$value) => inner($$value), () => inner());
                                                  template_effect(() => attributes_9 = set_attributes(input_9, attributes_9, {
                                                    ...$$restProps,
                                                    type: "datetime",
                                                    readonly: readonly(),
                                                    class: get(classes),
                                                    name: name(),
                                                    disabled: disabled(),
                                                    placeholder: placeholder()
                                                  }));
                                                  event("blur", input_9, function($$arg) {
                                                    bubble_event.call(this, $$props, $$arg);
                                                  });
                                                  event("change", input_9, function($$arg) {
                                                    bubble_event.call(this, $$props, $$arg);
                                                  });
                                                  event("focus", input_9, function($$arg) {
                                                    bubble_event.call(this, $$props, $$arg);
                                                  });
                                                  event("input", input_9, function($$arg) {
                                                    bubble_event.call(this, $$props, $$arg);
                                                  });
                                                  event("keydown", input_9, function($$arg) {
                                                    bubble_event.call(this, $$props, $$arg);
                                                  });
                                                  event("keypress", input_9, function($$arg) {
                                                    bubble_event.call(this, $$props, $$arg);
                                                  });
                                                  event("keyup", input_9, function($$arg) {
                                                    bubble_event.call(this, $$props, $$arg);
                                                  });
                                                  bind_value(input_9, value);
                                                  append($$anchor13, input_9);
                                                },
                                                ($$anchor13) => {
                                                  var fragment_13 = comment();
                                                  var node_13 = first_child(fragment_13);
                                                  if_block(
                                                    node_13,
                                                    () => strict_equals(type(), "datetime-local"),
                                                    ($$anchor14) => {
                                                      var input_10 = root_242();
                                                      remove_input_defaults(input_10);
                                                      let attributes_10;
                                                      bind_this(input_10, ($$value) => inner($$value), () => inner());
                                                      template_effect(() => attributes_10 = set_attributes(input_10, attributes_10, {
                                                        ...$$restProps,
                                                        class: get(classes),
                                                        type: "datetime-local",
                                                        disabled: disabled(),
                                                        name: name(),
                                                        placeholder: placeholder(),
                                                        readonly: readonly()
                                                      }));
                                                      event("blur", input_10, function($$arg) {
                                                        bubble_event.call(this, $$props, $$arg);
                                                      });
                                                      event("change", input_10, function($$arg) {
                                                        bubble_event.call(this, $$props, $$arg);
                                                      });
                                                      event("focus", input_10, function($$arg) {
                                                        bubble_event.call(this, $$props, $$arg);
                                                      });
                                                      event("input", input_10, function($$arg) {
                                                        bubble_event.call(this, $$props, $$arg);
                                                      });
                                                      event("keydown", input_10, function($$arg) {
                                                        bubble_event.call(this, $$props, $$arg);
                                                      });
                                                      event("keypress", input_10, function($$arg) {
                                                        bubble_event.call(this, $$props, $$arg);
                                                      });
                                                      event("keyup", input_10, function($$arg) {
                                                        bubble_event.call(this, $$props, $$arg);
                                                      });
                                                      bind_value(input_10, value);
                                                      append($$anchor14, input_10);
                                                    },
                                                    ($$anchor14) => {
                                                      var fragment_14 = comment();
                                                      var node_14 = first_child(fragment_14);
                                                      if_block(
                                                        node_14,
                                                        () => strict_equals(type(), "month"),
                                                        ($$anchor15) => {
                                                          var input_11 = root_262();
                                                          remove_input_defaults(input_11);
                                                          let attributes_11;
                                                          bind_this(input_11, ($$value) => inner($$value), () => inner());
                                                          template_effect(() => attributes_11 = set_attributes(input_11, attributes_11, {
                                                            ...$$restProps,
                                                            class: get(classes),
                                                            type: "month",
                                                            disabled: disabled(),
                                                            name: name(),
                                                            placeholder: placeholder(),
                                                            readonly: readonly()
                                                          }));
                                                          event("blur", input_11, function($$arg) {
                                                            bubble_event.call(this, $$props, $$arg);
                                                          });
                                                          event("change", input_11, function($$arg) {
                                                            bubble_event.call(this, $$props, $$arg);
                                                          });
                                                          event("focus", input_11, function($$arg) {
                                                            bubble_event.call(this, $$props, $$arg);
                                                          });
                                                          event("input", input_11, function($$arg) {
                                                            bubble_event.call(this, $$props, $$arg);
                                                          });
                                                          event("keydown", input_11, function($$arg) {
                                                            bubble_event.call(this, $$props, $$arg);
                                                          });
                                                          event("keypress", input_11, function($$arg) {
                                                            bubble_event.call(this, $$props, $$arg);
                                                          });
                                                          event("keyup", input_11, function($$arg) {
                                                            bubble_event.call(this, $$props, $$arg);
                                                          });
                                                          bind_value(input_11, value);
                                                          append($$anchor15, input_11);
                                                        },
                                                        ($$anchor15) => {
                                                          var fragment_15 = comment();
                                                          var node_15 = first_child(fragment_15);
                                                          if_block(
                                                            node_15,
                                                            () => strict_equals(type(), "color"),
                                                            ($$anchor16) => {
                                                              var input_12 = root_282();
                                                              remove_input_defaults(input_12);
                                                              let attributes_12;
                                                              bind_this(input_12, ($$value) => inner($$value), () => inner());
                                                              template_effect(() => attributes_12 = set_attributes(input_12, attributes_12, {
                                                                ...$$restProps,
                                                                type: "color",
                                                                readonly: readonly(),
                                                                class: get(classes),
                                                                name: name(),
                                                                disabled: disabled(),
                                                                placeholder: placeholder()
                                                              }));
                                                              event("blur", input_12, function($$arg) {
                                                                bubble_event.call(this, $$props, $$arg);
                                                              });
                                                              event("change", input_12, function($$arg) {
                                                                bubble_event.call(this, $$props, $$arg);
                                                              });
                                                              event("focus", input_12, function($$arg) {
                                                                bubble_event.call(this, $$props, $$arg);
                                                              });
                                                              event("input", input_12, function($$arg) {
                                                                bubble_event.call(this, $$props, $$arg);
                                                              });
                                                              event("keydown", input_12, function($$arg) {
                                                                bubble_event.call(this, $$props, $$arg);
                                                              });
                                                              event("keypress", input_12, function($$arg) {
                                                                bubble_event.call(this, $$props, $$arg);
                                                              });
                                                              event("keyup", input_12, function($$arg) {
                                                                bubble_event.call(this, $$props, $$arg);
                                                              });
                                                              bind_value(input_12, value);
                                                              append($$anchor16, input_12);
                                                            },
                                                            ($$anchor16) => {
                                                              var fragment_16 = comment();
                                                              var node_16 = first_child(fragment_16);
                                                              if_block(
                                                                node_16,
                                                                () => strict_equals(type(), "range"),
                                                                ($$anchor17) => {
                                                                  var input_13 = root_30();
                                                                  remove_input_defaults(input_13);
                                                                  let attributes_13;
                                                                  bind_this(input_13, ($$value) => inner($$value), () => inner());
                                                                  template_effect(() => attributes_13 = set_attributes(input_13, attributes_13, {
                                                                    ...$$restProps,
                                                                    type: "range",
                                                                    readonly: readonly(),
                                                                    class: get(classes),
                                                                    name: name(),
                                                                    disabled: disabled(),
                                                                    placeholder: placeholder()
                                                                  }));
                                                                  event("blur", input_13, function($$arg) {
                                                                    bubble_event.call(this, $$props, $$arg);
                                                                  });
                                                                  event("change", input_13, function($$arg) {
                                                                    bubble_event.call(this, $$props, $$arg);
                                                                  });
                                                                  event("focus", input_13, function($$arg) {
                                                                    bubble_event.call(this, $$props, $$arg);
                                                                  });
                                                                  event("input", input_13, function($$arg) {
                                                                    bubble_event.call(this, $$props, $$arg);
                                                                  });
                                                                  event("keydown", input_13, function($$arg) {
                                                                    bubble_event.call(this, $$props, $$arg);
                                                                  });
                                                                  event("keypress", input_13, function($$arg) {
                                                                    bubble_event.call(this, $$props, $$arg);
                                                                  });
                                                                  event("keyup", input_13, function($$arg) {
                                                                    bubble_event.call(this, $$props, $$arg);
                                                                  });
                                                                  bind_value(input_13, value);
                                                                  append($$anchor17, input_13);
                                                                },
                                                                ($$anchor17) => {
                                                                  var fragment_17 = comment();
                                                                  var node_17 = first_child(fragment_17);
                                                                  if_block(
                                                                    node_17,
                                                                    () => strict_equals(type(), "search"),
                                                                    ($$anchor18) => {
                                                                      var input_14 = root_322();
                                                                      remove_input_defaults(input_14);
                                                                      let attributes_14;
                                                                      bind_this(input_14, ($$value) => inner($$value), () => inner());
                                                                      template_effect(() => attributes_14 = set_attributes(input_14, attributes_14, {
                                                                        ...$$restProps,
                                                                        class: get(classes),
                                                                        type: "search",
                                                                        disabled: disabled(),
                                                                        name: name(),
                                                                        placeholder: placeholder(),
                                                                        readonly: readonly(),
                                                                        size: size()
                                                                      }));
                                                                      event("blur", input_14, function($$arg) {
                                                                        bubble_event.call(this, $$props, $$arg);
                                                                      });
                                                                      event("change", input_14, function($$arg) {
                                                                        bubble_event.call(this, $$props, $$arg);
                                                                      });
                                                                      event("focus", input_14, function($$arg) {
                                                                        bubble_event.call(this, $$props, $$arg);
                                                                      });
                                                                      event("input", input_14, function($$arg) {
                                                                        bubble_event.call(this, $$props, $$arg);
                                                                      });
                                                                      event("keydown", input_14, function($$arg) {
                                                                        bubble_event.call(this, $$props, $$arg);
                                                                      });
                                                                      event("keypress", input_14, function($$arg) {
                                                                        bubble_event.call(this, $$props, $$arg);
                                                                      });
                                                                      event("keyup", input_14, function($$arg) {
                                                                        bubble_event.call(this, $$props, $$arg);
                                                                      });
                                                                      bind_value(input_14, value);
                                                                      append($$anchor18, input_14);
                                                                    },
                                                                    ($$anchor18) => {
                                                                      var fragment_18 = comment();
                                                                      var node_18 = first_child(fragment_18);
                                                                      if_block(
                                                                        node_18,
                                                                        () => strict_equals(type(), "tel"),
                                                                        ($$anchor19) => {
                                                                          var input_15 = root_342();
                                                                          remove_input_defaults(input_15);
                                                                          let attributes_15;
                                                                          bind_this(input_15, ($$value) => inner($$value), () => inner());
                                                                          template_effect(() => attributes_15 = set_attributes(input_15, attributes_15, {
                                                                            ...$$restProps,
                                                                            class: get(classes),
                                                                            type: "tel",
                                                                            disabled: disabled(),
                                                                            name: name(),
                                                                            placeholder: placeholder(),
                                                                            readonly: readonly(),
                                                                            size: size()
                                                                          }));
                                                                          event("blur", input_15, function($$arg) {
                                                                            bubble_event.call(this, $$props, $$arg);
                                                                          });
                                                                          event("change", input_15, function($$arg) {
                                                                            bubble_event.call(this, $$props, $$arg);
                                                                          });
                                                                          event("focus", input_15, function($$arg) {
                                                                            bubble_event.call(this, $$props, $$arg);
                                                                          });
                                                                          event("input", input_15, function($$arg) {
                                                                            bubble_event.call(this, $$props, $$arg);
                                                                          });
                                                                          event("keydown", input_15, function($$arg) {
                                                                            bubble_event.call(this, $$props, $$arg);
                                                                          });
                                                                          event("keypress", input_15, function($$arg) {
                                                                            bubble_event.call(this, $$props, $$arg);
                                                                          });
                                                                          event("keyup", input_15, function($$arg) {
                                                                            bubble_event.call(this, $$props, $$arg);
                                                                          });
                                                                          bind_value(input_15, value);
                                                                          append($$anchor19, input_15);
                                                                        },
                                                                        ($$anchor19) => {
                                                                          var fragment_19 = comment();
                                                                          var node_19 = first_child(fragment_19);
                                                                          if_block(
                                                                            node_19,
                                                                            () => strict_equals(type(), "week"),
                                                                            ($$anchor20) => {
                                                                              var input_16 = root_36();
                                                                              remove_input_defaults(input_16);
                                                                              let attributes_16;
                                                                              bind_this(input_16, ($$value) => inner($$value), () => inner());
                                                                              template_effect(() => attributes_16 = set_attributes(input_16, attributes_16, {
                                                                                ...$$restProps,
                                                                                class: get(classes),
                                                                                type: "week",
                                                                                disabled: disabled(),
                                                                                name: name(),
                                                                                placeholder: placeholder(),
                                                                                readonly: readonly()
                                                                              }));
                                                                              event("blur", input_16, function($$arg) {
                                                                                bubble_event.call(this, $$props, $$arg);
                                                                              });
                                                                              event("change", input_16, function($$arg) {
                                                                                bubble_event.call(this, $$props, $$arg);
                                                                              });
                                                                              event("focus", input_16, function($$arg) {
                                                                                bubble_event.call(this, $$props, $$arg);
                                                                              });
                                                                              event("input", input_16, function($$arg) {
                                                                                bubble_event.call(this, $$props, $$arg);
                                                                              });
                                                                              event("keydown", input_16, function($$arg) {
                                                                                bubble_event.call(this, $$props, $$arg);
                                                                              });
                                                                              event("keypress", input_16, function($$arg) {
                                                                                bubble_event.call(this, $$props, $$arg);
                                                                              });
                                                                              event("keyup", input_16, function($$arg) {
                                                                                bubble_event.call(this, $$props, $$arg);
                                                                              });
                                                                              bind_value(input_16, value);
                                                                              append($$anchor20, input_16);
                                                                            },
                                                                            ($$anchor20) => {
                                                                              var input_17 = root_37();
                                                                              remove_input_defaults(input_17);
                                                                              let attributes_17;
                                                                              template_effect(() => attributes_17 = set_attributes(input_17, attributes_17, {
                                                                                ...$$restProps,
                                                                                type: type(),
                                                                                readonly: readonly(),
                                                                                class: get(classes),
                                                                                name: name(),
                                                                                disabled: disabled(),
                                                                                placeholder: placeholder(),
                                                                                value: value()
                                                                              }));
                                                                              event("blur", input_17, function($$arg) {
                                                                                bubble_event.call(this, $$props, $$arg);
                                                                              });
                                                                              event("change", input_17, handleInput);
                                                                              event("focus", input_17, function($$arg) {
                                                                                bubble_event.call(this, $$props, $$arg);
                                                                              });
                                                                              event("input", input_17, handleInput);
                                                                              event("keydown", input_17, function($$arg) {
                                                                                bubble_event.call(this, $$props, $$arg);
                                                                              });
                                                                              event("keypress", input_17, function($$arg) {
                                                                                bubble_event.call(this, $$props, $$arg);
                                                                              });
                                                                              event("keyup", input_17, function($$arg) {
                                                                                bubble_event.call(this, $$props, $$arg);
                                                                              });
                                                                              append($$anchor20, input_17);
                                                                            },
                                                                            true
                                                                          );
                                                                          append($$anchor19, fragment_19);
                                                                        },
                                                                        true
                                                                      );
                                                                      append($$anchor18, fragment_18);
                                                                    },
                                                                    true
                                                                  );
                                                                  append($$anchor17, fragment_17);
                                                                },
                                                                true
                                                              );
                                                              append($$anchor16, fragment_16);
                                                            },
                                                            true
                                                          );
                                                          append($$anchor15, fragment_15);
                                                        },
                                                        true
                                                      );
                                                      append($$anchor14, fragment_14);
                                                    },
                                                    true
                                                  );
                                                  append($$anchor13, fragment_13);
                                                },
                                                true
                                              );
                                              append($$anchor12, fragment_12);
                                            },
                                            true
                                          );
                                          append($$anchor11, fragment_11);
                                        },
                                        true
                                      );
                                      append($$anchor10, fragment_10);
                                    },
                                    true
                                  );
                                  append($$anchor9, fragment_9);
                                },
                                true
                              );
                              append($$anchor8, fragment_8);
                            },
                            true
                          );
                          append($$anchor7, fragment_6);
                        },
                        true
                      );
                      append($$anchor6, fragment_5);
                    },
                    true
                  );
                  append($$anchor5, fragment_4);
                },
                true
              );
              append($$anchor4, fragment_3);
            },
            true
          );
          append($$anchor3, fragment_2);
        }
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var fragment_20 = comment();
      var node_20 = first_child(fragment_20);
      if_block(
        node_20,
        () => strict_equals(get(tag), "textarea"),
        ($$anchor3) => {
          var textarea = root_39();
          remove_textarea_child(textarea);
          let attributes_18;
          bind_this(textarea, ($$value) => inner($$value), () => inner());
          template_effect(() => attributes_18 = set_attributes(textarea, attributes_18, {
            ...$$restProps,
            class: get(classes),
            disabled: disabled(),
            name: name(),
            placeholder: placeholder(),
            readonly: readonly()
          }));
          event("blur", textarea, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("change", textarea, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("focus", textarea, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("input", textarea, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("keydown", textarea, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("keypress", textarea, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          event("keyup", textarea, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          bind_value(textarea, value);
          append($$anchor3, textarea);
        },
        ($$anchor3) => {
          var fragment_21 = comment();
          var node_21 = first_child(fragment_21);
          if_block(
            node_21,
            () => strict_equals(get(tag), "select") && !multiple(),
            ($$anchor4) => {
              var select = root_41();
              template_effect(() => {
                value();
                invalidate_inner_signals(() => {
                  $$restProps;
                  get(classes);
                  inner();
                  name();
                  disabled();
                  readonly();
                });
              });
              let attributes_19;
              var node_22 = child(select);
              slot(node_22, $$props, "default", {}, null);
              reset(select);
              bind_this(select, ($$value) => inner($$value), () => inner());
              template_effect(() => attributes_19 = set_attributes(select, attributes_19, {
                ...$$restProps,
                class: get(classes),
                name: name(),
                disabled: disabled(),
                readonly: readonly()
              }));
              event("blur", select, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event("change", select, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event("focus", select, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              event("input", select, function($$arg) {
                bubble_event.call(this, $$props, $$arg);
              });
              bind_select_value(select, value);
              append($$anchor4, select);
            },
            null,
            true
          );
          append($$anchor3, fragment_21);
        },
        true
      );
      append($$anchor2, fragment_20);
    }
  );
  var node_23 = sibling(node, 2);
  if_block(node_23, feedback, ($$anchor2) => {
    var fragment_22 = comment();
    var node_24 = first_child(fragment_22);
    if_block(
      node_24,
      () => Array.isArray(feedback()),
      ($$anchor3) => {
        var fragment_23 = comment();
        var node_25 = first_child(fragment_23);
        each(node_25, 1, feedback, index, ($$anchor4, msg) => {
          var fragment_24 = comment();
          var node_26 = first_child(fragment_24);
          FormFeedback_default(node_26, {
            get valid() {
              return valid();
            },
            children: wrap_snippet(Input, ($$anchor5, $$slotProps) => {
              next();
              var text2 = text();
              template_effect(() => set_text(text2, get(msg)));
              append($$anchor5, text2);
            }),
            $$slots: { default: true }
          });
          append($$anchor4, fragment_24);
        });
        append($$anchor3, fragment_23);
      },
      ($$anchor3) => {
        var fragment_26 = comment();
        var node_27 = first_child(fragment_26);
        FormFeedback_default(node_27, {
          get valid() {
            return valid();
          },
          children: wrap_snippet(Input, ($$anchor4, $$slotProps) => {
            next();
            var text_1 = text();
            template_effect(() => set_text(text_1, feedback()));
            append($$anchor4, text_1);
          }),
          $$slots: { default: true }
        });
        append($$anchor3, fragment_26);
      }
    );
    append($$anchor2, fragment_22);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Input = hmr(Input, () => Input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Input[HMR].source;
    set(Input[HMR].source, module.default[HMR].original);
  });
}
var Input_default = Input;
mark_module_end(Input);

// ../node_modules/sveltestrap/src/InputGroup.svelte
mark_module_start();
InputGroup[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/InputGroup.svelte";
var root37 = add_locations(template(`<div><!></div>`), InputGroup[FILENAME], [[15, 0]]);
function InputGroup($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class", "size"]);
  push($$props, false, InputGroup);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  let size = prop($$props, "size", 8, "");
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(size())),
    () => {
      set(classes, classnames(className(), "input-group", size() ? `input-group-${size()}` : null));
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root37();
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  template_effect(() => attributes = set_attributes(div, attributes, { ...$$restProps, class: get(classes) }));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  InputGroup = hmr(InputGroup, () => InputGroup[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InputGroup[HMR].source;
    set(InputGroup[HMR].source, module.default[HMR].original);
  });
}
var InputGroup_default = InputGroup;
mark_module_end(InputGroup);

// ../node_modules/sveltestrap/src/InputGroupText.svelte
mark_module_start();
InputGroupText[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/InputGroupText.svelte";
var root38 = add_locations(template(`<span><!></span>`), InputGroupText[FILENAME], [[10, 0]]);
function InputGroupText($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class"]);
  push($$props, false, InputGroupText);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  legacy_pre_effect(
    () => (classnames, deep_read_state(className())),
    () => {
      set(classes, classnames(className(), "input-group-text"));
    }
  );
  legacy_pre_effect_reset();
  init();
  var span = root38();
  let attributes;
  var node = child(span);
  slot(node, $$props, "default", {}, null);
  reset(span);
  template_effect(() => attributes = set_attributes(span, attributes, { ...$$restProps, class: get(classes) }));
  append($$anchor, span);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  InputGroupText = hmr(InputGroupText, () => InputGroupText[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InputGroupText[HMR].source;
    set(InputGroupText[HMR].source, module.default[HMR].original);
  });
}
var InputGroupText_default = InputGroupText;
mark_module_end(InputGroupText);

// ../node_modules/sveltestrap/src/Jumbotron.svelte
mark_module_start();
Jumbotron[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/Jumbotron.svelte";
var root39 = add_locations(template(`<div><!></div>`), Jumbotron[FILENAME], [[10, 0]]);
function Jumbotron($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Jumbotron);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  legacy_pre_effect(
    () => (classnames, deep_read_state(className())),
    () => {
      set(classes, classnames(className(), "p-5 mb-4 bg-light rounded-3"));
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root39();
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  template_effect(() => set_class(div, get(classes)));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Jumbotron = hmr(Jumbotron, () => Jumbotron[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Jumbotron[HMR].source;
    set(Jumbotron[HMR].source, module.default[HMR].original);
  });
}
var Jumbotron_default = Jumbotron;
mark_module_end(Jumbotron);

// ../node_modules/sveltestrap/src/Label.svelte
mark_module_start();
Label[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/Label.svelte";
var root40 = add_locations(template(`<label><!></label>`), Label[FILENAME], [[72, 0]]);
function Label($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "class",
    "hidden",
    "check",
    "size",
    "for",
    "xs",
    "sm",
    "md",
    "lg",
    "xl",
    "xxl",
    "widths"
  ]);
  push($$props, false, Label);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  let hidden = prop($$props, "hidden", 8, false);
  let check = prop($$props, "check", 8, false);
  let size = prop($$props, "size", 8, "");
  let fore = prop($$props, "for", 8, null);
  let xs = prop($$props, "xs", 8, "");
  let sm = prop($$props, "sm", 8, "");
  let md = prop($$props, "md", 8, "");
  let lg = prop($$props, "lg", 8, "");
  let xl = prop($$props, "xl", 8, "");
  let xxl = prop($$props, "xxl", 8, "");
  const colWidths = {
    xs: xs(),
    sm: sm(),
    md: md(),
    lg: lg(),
    xl: xl(),
    xxl: xxl()
  };
  let widths = prop($$props, "widths", 24, () => Object.keys(colWidths));
  const colClasses = [];
  widths().forEach((colWidth) => {
    let columnProp = $$sanitized_props[colWidth];
    if (!columnProp && strict_equals(columnProp, "", false)) {
      return;
    }
    const isXs = strict_equals(colWidth, "xs");
    let colClass;
    if (isObject(columnProp)) {
      const colSizeInterfix = isXs ? "-" : `-${colWidth}-`;
      colClass = getColumnSizeClass(isXs, colWidth, columnProp.size);
      colClasses.push(classnames({
        [colClass]: columnProp.size || strict_equals(columnProp.size, ""),
        [`order${colSizeInterfix}${columnProp.order}`]: columnProp.order || strict_equals(columnProp.order, 0),
        [`offset${colSizeInterfix}${columnProp.offset}`]: columnProp.offset || strict_equals(columnProp.offset, 0)
      }));
    } else {
      colClass = getColumnSizeClass(isXs, colWidth, columnProp);
      colClasses.push(colClass);
    }
  });
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(hidden()), deep_read_state(check()), deep_read_state(size())),
    () => {
      set(classes, classnames(className(), hidden() ? "visually-hidden" : false, check() ? "form-check-label" : false, size() ? `col-form-label-${size()}` : false, colClasses, colClasses.length ? "col-form-label" : "form-label"));
    }
  );
  legacy_pre_effect_reset();
  init();
  var label = root40();
  let attributes;
  var node = child(label);
  slot(node, $$props, "default", {}, null);
  reset(label);
  template_effect(() => attributes = set_attributes(label, attributes, {
    ...$$restProps,
    class: get(classes),
    for: fore()
  }));
  append($$anchor, label);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Label = hmr(Label, () => Label[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Label[HMR].source;
    set(Label[HMR].source, module.default[HMR].original);
  });
}
var Label_default = Label;
mark_module_end(Label);

// ../node_modules/sveltestrap/src/ListGroup.svelte
mark_module_start();
ListGroup[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/ListGroup.svelte";
var root_117 = add_locations(template(`<ol><!></ol>`), ListGroup[FILENAME], [[18, 2]]);
var root_29 = add_locations(template(`<ul><!></ul>`), ListGroup[FILENAME], [[22, 2]]);
function ListGroup($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class", "flush", "horizontal", "numbered"]);
  push($$props, false, ListGroup);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  let flush = prop($$props, "flush", 8, false);
  let horizontal = prop($$props, "horizontal", 8, false);
  let numbered = prop($$props, "numbered", 8, false);
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(flush()), deep_read_state(horizontal()), deep_read_state(numbered())),
    () => {
      set(classes, classnames(className(), "list-group", {
        "list-group-flush": flush(),
        "list-group-horizontal": horizontal(),
        "list-group-numbered": numbered()
      }));
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    numbered,
    ($$anchor2) => {
      var ol = root_117();
      let attributes;
      var node_1 = child(ol);
      slot(node_1, $$props, "default", {}, null);
      reset(ol);
      template_effect(() => attributes = set_attributes(ol, attributes, { ...$$restProps, class: get(classes) }));
      append($$anchor2, ol);
    },
    ($$anchor2) => {
      var ul = root_29();
      let attributes_1;
      var node_2 = child(ul);
      slot(node_2, $$props, "default", {}, null);
      reset(ul);
      template_effect(() => attributes_1 = set_attributes(ul, attributes_1, { ...$$restProps, class: get(classes) }));
      append($$anchor2, ul);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ListGroup = hmr(ListGroup, () => ListGroup[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ListGroup[HMR].source;
    set(ListGroup[HMR].source, module.default[HMR].original);
  });
}
var ListGroup_default = ListGroup;
mark_module_end(ListGroup);

// ../node_modules/sveltestrap/src/ListGroupItem.svelte
mark_module_start();
ListGroupItem[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/ListGroupItem.svelte";
var root_118 = add_locations(template(`<a><!></a>`), ListGroupItem[FILENAME], [[22, 2]]);
var root_38 = add_locations(template(`<button><!></button>`), ListGroupItem[FILENAME], [[26, 2]]);
var root_47 = add_locations(template(`<li><!></li>`), ListGroupItem[FILENAME], [[39, 2]]);
function ListGroupItem($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "class",
    "active",
    "disabled",
    "color",
    "action",
    "href",
    "tag"
  ]);
  push($$props, false, ListGroupItem);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  let active = prop($$props, "active", 8, false);
  let disabled = prop($$props, "disabled", 8, false);
  let color = prop($$props, "color", 8, "");
  let action2 = prop($$props, "action", 8, false);
  let href = prop($$props, "href", 8, null);
  let tag = prop($$props, "tag", 8, null);
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(active()), deep_read_state(disabled()), deep_read_state(action2()), deep_read_state(tag()), deep_read_state(color())),
    () => {
      set(classes, classnames(className(), "list-group-item", {
        active: active(),
        disabled: disabled(),
        "list-group-item-action": action2() || strict_equals(tag(), "button"),
        [`list-group-item-${color()}`]: color()
      }));
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    href,
    ($$anchor2) => {
      var a = root_118();
      let attributes;
      var node_1 = child(a);
      slot(node_1, $$props, "default", {}, null);
      reset(a);
      template_effect(() => attributes = set_attributes(a, attributes, {
        ...$$restProps,
        class: get(classes),
        href: href(),
        disabled: disabled(),
        active: active()
      }));
      event("click", a, function($$arg) {
        bubble_event.call(this, $$props, $$arg);
      });
      append($$anchor2, a);
    },
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_2 = first_child(fragment_1);
      if_block(
        node_2,
        () => strict_equals(tag(), "button"),
        ($$anchor3) => {
          var button = root_38();
          let attributes_1;
          var node_3 = child(button);
          slot(node_3, $$props, "default", {}, null);
          reset(button);
          template_effect(() => attributes_1 = set_attributes(button, attributes_1, {
            ...$$restProps,
            class: get(classes),
            type: "button",
            disabled: disabled(),
            active: active()
          }));
          event("click", button, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          append($$anchor3, button);
        },
        ($$anchor3) => {
          var li = root_47();
          let attributes_2;
          var node_4 = child(li);
          slot(node_4, $$props, "default", {}, null);
          reset(li);
          template_effect(() => attributes_2 = set_attributes(li, attributes_2, {
            ...$$restProps,
            class: get(classes),
            disabled: disabled(),
            active: active()
          }));
          event("click", li, function($$arg) {
            bubble_event.call(this, $$props, $$arg);
          });
          append($$anchor3, li);
        },
        true
      );
      append($$anchor2, fragment_1);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ListGroupItem = hmr(ListGroupItem, () => ListGroupItem[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ListGroupItem[HMR].source;
    set(ListGroupItem[HMR].source, module.default[HMR].original);
  });
}
var ListGroupItem_default = ListGroupItem;
mark_module_end(ListGroupItem);

// ../node_modules/sveltestrap/src/ModalBackdrop.svelte
mark_module_start();
ModalBackdrop[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/ModalBackdrop.svelte";
var root_119 = add_locations(template(`<div></div>`), ModalBackdrop[FILENAME], [[21, 2]]);
function ModalBackdrop($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class", "isOpen", "fade"]);
  push($$props, false, ModalBackdrop);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  let isOpen = prop($$props, "isOpen", 8, false);
  let fade2 = prop($$props, "fade", 8, true);
  let loaded = mutable_state(false);
  onMount(() => {
    set(loaded, true);
  });
  legacy_pre_effect(
    () => (classnames, deep_read_state(className())),
    () => {
      set(classes, classnames(className(), "modal-backdrop"));
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(node, () => isOpen() && get(loaded), ($$anchor2) => {
    var div = root_119();
    let attributes;
    template_effect(() => {
      attributes = set_attributes(div, attributes, {
        role: "presentation",
        ...$$restProps,
        class: get(classes)
      });
      toggle_class(div, "fade", fade2());
    });
    event("click", div, function($$arg) {
      bubble_event.call(this, $$props, $$arg);
    });
    transition(1, div, () => backdropIn);
    transition(2, div, () => backdropOut);
    append($$anchor2, div);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ModalBackdrop = hmr(ModalBackdrop, () => ModalBackdrop[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ModalBackdrop[HMR].source;
    set(ModalBackdrop[HMR].source, module.default[HMR].original);
  });
}
var ModalBackdrop_default = ModalBackdrop;
mark_module_end(ModalBackdrop);

// ../node_modules/sveltestrap/src/ModalBody.svelte
mark_module_start();
ModalBody[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/ModalBody.svelte";
var root41 = add_locations(template(`<div><!></div>`), ModalBody[FILENAME], [[10, 0]]);
function ModalBody($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class"]);
  push($$props, false, ModalBody);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  legacy_pre_effect(
    () => (classnames, deep_read_state(className())),
    () => {
      set(classes, classnames(className(), "modal-body"));
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root41();
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  template_effect(() => attributes = set_attributes(div, attributes, { ...$$restProps, class: get(classes) }));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ModalBody = hmr(ModalBody, () => ModalBody[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ModalBody[HMR].source;
    set(ModalBody[HMR].source, module.default[HMR].original);
  });
}
var ModalBody_default = ModalBody;
mark_module_end(ModalBody);

// ../node_modules/sveltestrap/src/ModalHeader.svelte
mark_module_start();
ModalHeader[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/ModalHeader.svelte";
var root_48 = add_locations(template(`<button type="button" class="btn-close"></button>`), ModalHeader[FILENAME], [[24, 6]]);
var root42 = add_locations(template(`<div><h5 class="modal-title"><!></h5> <!></div>`), ModalHeader[FILENAME], [[14, 0, [[15, 2]]]]);
function ModalHeader($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "class",
    "toggle",
    "closeAriaLabel",
    "children",
    "id"
  ]);
  push($$props, false, ModalHeader);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  let toggle = prop($$props, "toggle", 8, void 0);
  let closeAriaLabel = prop($$props, "closeAriaLabel", 8, "Close");
  let children = prop($$props, "children", 8, void 0);
  let id = prop($$props, "id", 8, void 0);
  legacy_pre_effect(
    () => (classnames, deep_read_state(className())),
    () => {
      set(classes, classnames(className(), "modal-header"));
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root42();
  let attributes;
  var h5 = child(div);
  var node = child(h5);
  if_block(
    node,
    children,
    ($$anchor2) => {
      var text2 = text();
      template_effect(() => set_text(text2, children()));
      append($$anchor2, text2);
    },
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, $$props, "default", {}, null);
      append($$anchor2, fragment_1);
    }
  );
  reset(h5);
  var node_2 = sibling(h5, 2);
  slot(node_2, $$props, "close", {}, ($$anchor2) => {
    var fragment_2 = comment();
    var node_3 = first_child(fragment_2);
    if_block(node_3, () => strict_equals(typeof toggle(), "function"), ($$anchor3) => {
      var button = root_48();
      template_effect(() => set_attribute(button, "aria-label", closeAriaLabel()));
      event("click", button, function(...$$args) {
        apply(toggle, this, $$args, ModalHeader, [26, 18]);
      });
      append($$anchor3, button);
    });
    append($$anchor2, fragment_2);
  });
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps, class: get(classes) });
    set_attribute(h5, "id", id());
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ModalHeader = hmr(ModalHeader, () => ModalHeader[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ModalHeader[HMR].source;
    set(ModalHeader[HMR].source, module.default[HMR].original);
  });
}
var ModalHeader_default = ModalHeader;
mark_module_end(ModalHeader);

// ../node_modules/sveltestrap/src/Portal.svelte
mark_module_start();
Portal[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/Portal.svelte";
var root43 = add_locations(template(`<div><!></div>`), Portal[FILENAME], [[19, 0]]);
function Portal($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, []);
  push($$props, false, Portal);
  let ref = mutable_state();
  let portal;
  onMount(() => {
    portal = document.createElement("div");
    document.body.appendChild(portal);
    portal.appendChild(get(ref));
  });
  onDestroy(() => {
    if (strict_equals(typeof document, "undefined", false)) {
      document.body.removeChild(portal);
    }
  });
  init();
  var div = root43();
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  bind_this(div, ($$value) => set(ref, $$value), () => get(ref));
  template_effect(() => attributes = set_attributes(div, attributes, { ...$$restProps }));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Portal = hmr(Portal, () => Portal[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Portal[HMR].source;
    set(Portal[HMR].source, module.default[HMR].original);
  });
}
var Portal_default = Portal;
mark_module_end(Portal);

// ../node_modules/sveltestrap/src/Modal.svelte
mark_module_start();
Modal[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/Modal.svelte";
var openCount = 0;
var root_310 = add_locations(template(`<div role="dialog"><!> <div role="document"><div><!> <!></div></div></div>`), Modal[FILENAME], [
  [
    229,
    8,
    [[246, 10, [[247, 12]]]]
  ]
]);
var root_210 = add_locations(template(`<div><!></div>`), Modal[FILENAME], [[226, 4]]);
var root44 = add_locations(template(`<!> <!>`, 1), Modal[FILENAME], []);
var $$css = {
  hash: "s-9aJnBVQYkK8W",
  code: "\n  .modal-open {\n    overflow: hidden;\n    padding-right: 0;\n  }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTW9kYWwuc3ZlbHRlIiwibWFwcGluZ3MiOiI7QUFpUkEsRUFBVSxXQUFZLENBQUM7QUFDdkIsSUFBSSxnQkFBZ0I7QUFDcEIsSUFBSSxnQkFBZ0I7QUFDcEIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIk1vZGFsLnN2ZWx0ZSJdfQ== */"
};
function Modal($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "class",
    "static",
    "isOpen",
    "autoFocus",
    "body",
    "centered",
    "container",
    "fullscreen",
    "header",
    "scrollable",
    "size",
    "toggle",
    "labelledBy",
    "backdrop",
    "wrapClassName",
    "modalClassName",
    "contentClassName",
    "fade",
    "unmountOnClose",
    "returnFocusAfterClose"
  ]);
  push($$props, false, Modal);
  append_styles($$anchor, $$css);
  const classes = mutable_state();
  const outer = mutable_state();
  const dispatch = createEventDispatcher();
  let className = prop($$props, "class", 8, "");
  let staticModal = prop($$props, "static", 8, false);
  let isOpen = prop($$props, "isOpen", 8, false);
  let autoFocus = prop($$props, "autoFocus", 8, true);
  let body = prop($$props, "body", 8, false);
  let centered = prop($$props, "centered", 8, false);
  let container = prop($$props, "container", 8, void 0);
  let fullscreen = prop($$props, "fullscreen", 8, false);
  let header = prop($$props, "header", 8, void 0);
  let scrollable = prop($$props, "scrollable", 8, false);
  let size = prop($$props, "size", 8, "");
  let toggle = prop($$props, "toggle", 8, void 0);
  let labelledBy = prop($$props, "labelledBy", 24, () => header() ? `modal-${uuid()}` : void 0);
  let backdrop = prop($$props, "backdrop", 8, true);
  let wrapClassName = prop($$props, "wrapClassName", 8, "");
  let modalClassName = prop($$props, "modalClassName", 8, "");
  let contentClassName = prop($$props, "contentClassName", 8, "");
  let fade2 = prop($$props, "fade", 8, true);
  let unmountOnClose = prop($$props, "unmountOnClose", 8, true);
  let returnFocusAfterClose = prop($$props, "returnFocusAfterClose", 8, true);
  let hasOpened = false;
  let _isMounted = mutable_state(false);
  let _triggeringElement;
  let _originalBodyPadding;
  let _lastIsOpen = isOpen();
  let _lastHasOpened = hasOpened;
  let _dialog = mutable_state();
  let _mouseDownElement;
  let _removeEscListener;
  onMount(() => {
    if (isOpen()) {
      init2();
      hasOpened = true;
    }
    if (hasOpened && autoFocus()) {
      setFocus();
    }
  });
  onDestroy(() => {
    destroy();
    if (hasOpened) {
      close();
    }
  });
  afterUpdate(() => {
    if (isOpen() && !_lastIsOpen) {
      init2();
      hasOpened = true;
    }
    if (autoFocus() && hasOpened && !_lastHasOpened) {
      setFocus();
    }
    _lastIsOpen = isOpen();
    _lastHasOpened = hasOpened;
  });
  function setFocus() {
    if (get(_dialog) && get(_dialog).parentNode && strict_equals(typeof get(_dialog).parentNode.focus, "function")) {
      get(_dialog).parentNode.focus();
    }
  }
  function init2() {
    try {
      _triggeringElement = document.activeElement;
    } catch (err) {
      _triggeringElement = null;
    }
    if (!staticModal()) {
      _originalBodyPadding = getOriginalBodyPadding();
      conditionallyUpdateScrollbar();
      if (strict_equals(openCount, 0)) {
        document.body.className = classnames(document.body.className, "modal-open");
      }
      openCount += 1;
    }
    set(_isMounted, true);
  }
  function manageFocusAfterClose() {
    if (_triggeringElement) {
      if (strict_equals(typeof _triggeringElement.focus, "function") && returnFocusAfterClose()) {
        _triggeringElement.focus();
      }
      _triggeringElement = null;
    }
  }
  function destroy() {
    manageFocusAfterClose();
  }
  function close() {
    if (openCount <= 1) {
      document.body.classList.remove("modal-open");
    }
    manageFocusAfterClose();
    openCount = Math.max(0, openCount - 1);
    setScrollbarWidth(_originalBodyPadding);
  }
  function handleBackdropClick(e) {
    if (strict_equals(e.target, _mouseDownElement)) {
      if (!isOpen() || !backdrop()) {
        return;
      }
      const backdropElem = get(_dialog) ? get(_dialog).parentNode : null;
      if (strict_equals(backdrop(), true) && backdropElem && strict_equals(e.target, backdropElem) && toggle()) {
        e.stopPropagation();
        toggle()(e);
      }
    }
  }
  function onModalOpened() {
    dispatch("open");
    _removeEscListener = browserEvent(document, "keydown", (event2) => {
      if (event2.key && strict_equals(event2.key, "Escape")) {
        if (toggle() && strict_equals(backdrop(), true)) {
          if (_removeEscListener) _removeEscListener();
          toggle()(event2);
        }
      }
    });
  }
  function onModalClosing() {
    dispatch("closing");
    if (_removeEscListener) {
      _removeEscListener();
    }
  }
  function onModalClosed() {
    dispatch("close");
    if (unmountOnClose()) {
      destroy();
    }
    close();
    if (get(_isMounted)) {
      hasOpened = false;
    }
    set(_isMounted, false);
  }
  function handleBackdropMouseDown(e) {
    _mouseDownElement = e.target;
  }
  const dialogBaseClass = "modal-dialog";
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(size()), deep_read_state(fullscreen()), deep_read_state(centered()), deep_read_state(scrollable())),
    () => {
      set(classes, classnames(dialogBaseClass, className(), {
        [`modal-${size()}`]: size(),
        "modal-fullscreen": strict_equals(fullscreen(), true),
        [`modal-fullscreen-${fullscreen()}-down`]: fullscreen() && strict_equals(typeof fullscreen(), "string"),
        [`${dialogBaseClass}-centered`]: centered(),
        [`${dialogBaseClass}-scrollable`]: scrollable()
      }));
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(container()), deep_read_state(staticModal()), InlineContainer_default, Portal_default),
    () => {
      set(outer, strict_equals(container(), "inline") || staticModal() ? InlineContainer_default : Portal_default);
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = root44();
  var node = first_child(fragment);
  if_block(node, () => get(_isMounted), ($$anchor2) => {
    var fragment_1 = comment();
    var node_1 = first_child(fragment_1);
    component(node_1, () => get(outer), ($$anchor3, $$component) => {
      $$component($$anchor3, {
        children: wrap_snippet(Modal, ($$anchor4, $$slotProps) => {
          var div = root_210();
          let attributes;
          var node_2 = child(div);
          if_block(node_2, isOpen, ($$anchor5) => {
            var div_1 = root_310();
            const class_derived = derived_safe_equal(() => classnames("modal", modalClassName(), {
              fade: fade2(),
              "position-static": staticModal()
            }));
            var node_3 = child(div_1);
            slot(node_3, $$props, "external", {}, null);
            var div_2 = sibling(node_3, 2);
            var div_3 = child(div_2);
            const class_derived_1 = derived_safe_equal(() => classnames("modal-content", contentClassName()));
            var node_4 = child(div_3);
            if_block(node_4, header, ($$anchor6) => {
              var fragment_2 = comment();
              var node_5 = first_child(fragment_2);
              ModalHeader_default(node_5, {
                get toggle() {
                  return toggle();
                },
                get id() {
                  return labelledBy();
                },
                children: wrap_snippet(Modal, ($$anchor7, $$slotProps2) => {
                  next();
                  var text2 = text();
                  template_effect(() => set_text(text2, header()));
                  append($$anchor7, text2);
                }),
                $$slots: { default: true }
              });
              append($$anchor6, fragment_2);
            });
            var node_6 = sibling(node_4, 2);
            if_block(
              node_6,
              body,
              ($$anchor6) => {
                var fragment_4 = comment();
                var node_7 = first_child(fragment_4);
                ModalBody_default(node_7, {
                  children: wrap_snippet(Modal, ($$anchor7, $$slotProps2) => {
                    var fragment_5 = comment();
                    var node_8 = first_child(fragment_5);
                    slot(node_8, $$props, "default", {}, null);
                    append($$anchor7, fragment_5);
                  }),
                  $$slots: { default: true }
                });
                append($$anchor6, fragment_4);
              },
              ($$anchor6) => {
                var fragment_6 = comment();
                var node_9 = first_child(fragment_6);
                slot(node_9, $$props, "default", {}, null);
                append($$anchor6, fragment_6);
              }
            );
            reset(div_3);
            reset(div_2);
            bind_this(div_2, ($$value) => set(_dialog, $$value), () => get(_dialog));
            reset(div_1);
            template_effect(() => {
              set_attribute(div_1, "aria-labelledby", labelledBy());
              set_class(div_1, get(class_derived));
              set_class(div_2, get(classes));
              set_class(div_3, get(class_derived_1));
            });
            transition(1, div_1, () => modalIn);
            transition(2, div_1, () => modalOut);
            event("introstart", div_1, () => dispatch("opening"));
            event("introend", div_1, onModalOpened);
            event("outrostart", div_1, onModalClosing);
            event("outroend", div_1, onModalClosed);
            event("click", div_1, handleBackdropClick);
            event("mousedown", div_1, handleBackdropMouseDown);
            append($$anchor5, div_1);
          });
          reset(div);
          template_effect(() => attributes = set_attributes(
            div,
            attributes,
            {
              class: wrapClassName(),
              tabindex: "-1",
              ...$$restProps
            },
            "s-9aJnBVQYkK8W"
          ));
          append($$anchor4, div);
        }),
        $$slots: { default: true }
      });
    });
    append($$anchor2, fragment_1);
  });
  var node_10 = sibling(node, 2);
  if_block(node_10, () => backdrop() && !staticModal(), ($$anchor2) => {
    var fragment_7 = comment();
    var node_11 = first_child(fragment_7);
    component(node_11, () => get(outer), ($$anchor3, $$component) => {
      $$component($$anchor3, {
        children: wrap_snippet(Modal, ($$anchor4, $$slotProps) => {
          var fragment_8 = comment();
          var node_12 = first_child(fragment_8);
          ModalBackdrop_default(node_12, {
            get fade() {
              return fade2();
            },
            get isOpen() {
              return isOpen();
            }
          });
          append($$anchor4, fragment_8);
        }),
        $$slots: { default: true }
      });
    });
    append($$anchor2, fragment_7);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Modal = hmr(Modal, () => Modal[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-9aJnBVQYkK8W");
    module.default[HMR].source = Modal[HMR].source;
    set(Modal[HMR].source, module.default[HMR].original);
  });
}
var Modal_default = Modal;
mark_module_end(Modal);

// ../node_modules/sveltestrap/src/ModalFooter.svelte
mark_module_start();
ModalFooter[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/ModalFooter.svelte";
var root45 = add_locations(template(`<div><!></div>`), ModalFooter[FILENAME], [[10, 0]]);
function ModalFooter($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class"]);
  push($$props, false, ModalFooter);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  legacy_pre_effect(
    () => (classnames, deep_read_state(className())),
    () => {
      set(classes, classnames(className(), "modal-footer"));
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root45();
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  template_effect(() => attributes = set_attributes(div, attributes, { ...$$restProps, class: get(classes) }));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ModalFooter = hmr(ModalFooter, () => ModalFooter[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ModalFooter[HMR].source;
    set(ModalFooter[HMR].source, module.default[HMR].original);
  });
}
var ModalFooter_default = ModalFooter;
mark_module_end(ModalFooter);

// ../node_modules/sveltestrap/src/Nav.svelte
mark_module_start();
Nav[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/Nav.svelte";
var root46 = add_locations(template(`<ul><!></ul>`), Nav[FILENAME], [[42, 0]]);
function Nav($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "class",
    "tabs",
    "pills",
    "vertical",
    "horizontal",
    "justified",
    "fill",
    "navbar",
    "card",
    "underline"
  ]);
  push($$props, false, Nav);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  let tabs = prop($$props, "tabs", 8, false);
  let pills = prop($$props, "pills", 8, false);
  let vertical = prop($$props, "vertical", 8, false);
  let horizontal = prop($$props, "horizontal", 8, "");
  let justified = prop($$props, "justified", 8, false);
  let fill = prop($$props, "fill", 8, false);
  let navbar = prop($$props, "navbar", 8, false);
  let card = prop($$props, "card", 8, false);
  let underline = prop($$props, "underline", 8, false);
  function getVerticalClass(vertical2) {
    if (strict_equals(vertical2, false)) {
      return false;
    } else if (strict_equals(vertical2, true) || strict_equals(vertical2, "xs")) {
      return "flex-column";
    }
    return `flex-${vertical2}-column`;
  }
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(navbar()), deep_read_state(horizontal()), deep_read_state(vertical()), deep_read_state(tabs()), deep_read_state(card()), deep_read_state(pills()), deep_read_state(justified()), deep_read_state(fill()), deep_read_state(underline())),
    () => {
      set(classes, classnames(className(), navbar() ? "navbar-nav" : "nav", horizontal() ? `justify-content-${horizontal()}` : false, getVerticalClass(vertical()), {
        "nav-tabs": tabs(),
        "card-header-tabs": card() && tabs(),
        "nav-pills": pills(),
        "card-header-pills": card() && pills(),
        "nav-justified": justified(),
        "nav-fill": fill(),
        "nav-underline": underline()
      }));
    }
  );
  legacy_pre_effect_reset();
  init();
  var ul = root46();
  let attributes;
  var node = child(ul);
  slot(node, $$props, "default", {}, null);
  reset(ul);
  template_effect(() => attributes = set_attributes(ul, attributes, { ...$$restProps, class: get(classes) }));
  append($$anchor, ul);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Nav = hmr(Nav, () => Nav[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Nav[HMR].source;
    set(Nav[HMR].source, module.default[HMR].original);
  });
}
var Nav_default = Nav;
mark_module_end(Nav);

// ../node_modules/sveltestrap/src/Navbar.svelte
mark_module_start();
Navbar[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/Navbar.svelte";
var root47 = add_locations(template(`<nav><!></nav>`), Navbar[FILENAME], [[39, 0]]);
function Navbar($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "class",
    "container",
    "color",
    "dark",
    "expand",
    "fixed",
    "light",
    "sticky"
  ]);
  push($$props, false, Navbar);
  const theme = mutable_state();
  const classes = mutable_state();
  setContext("navbar", { inNavbar: true });
  let className = prop($$props, "class", 8, "");
  let container = prop($$props, "container", 8, "fluid");
  let color = prop($$props, "color", 8, "");
  let dark = prop($$props, "dark", 8, false);
  let expand = prop($$props, "expand", 8, "");
  let fixed = prop($$props, "fixed", 8, "");
  let light = prop($$props, "light", 8, false);
  let sticky = prop($$props, "sticky", 8, "");
  function getExpandClass(expand2) {
    if (strict_equals(expand2, false)) {
      return false;
    } else if (strict_equals(expand2, true) || strict_equals(expand2, "xs")) {
      return "navbar-expand";
    }
    return `navbar-expand-${expand2}`;
  }
  legacy_pre_effect(
    () => (deep_read_state(dark()), deep_read_state(light())),
    () => {
      set(theme, dark() ? "dark" : light() ? "light" : void 0);
    }
  );
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(expand()), deep_read_state(color()), deep_read_state(fixed()), deep_read_state(sticky())),
    () => {
      set(classes, classnames(className(), "navbar", getExpandClass(expand()), {
        [`bg-${color()}`]: color(),
        [`fixed-${fixed()}`]: fixed(),
        [`sticky-${sticky()}`]: sticky()
      }));
    }
  );
  legacy_pre_effect_reset();
  init();
  var nav = root47();
  let attributes;
  var node = child(nav);
  if_block(
    node,
    container,
    ($$anchor2) => {
      var fragment = comment();
      var node_1 = first_child(fragment);
      var fluid = derived_safe_equal(() => strict_equals(container(), "fluid"));
      Container_default(node_1, {
        get fluid() {
          return get(fluid);
        },
        children: wrap_snippet(Navbar, ($$anchor3, $$slotProps) => {
          var fragment_1 = comment();
          var node_2 = first_child(fragment_1);
          slot(node_2, $$props, "default", {}, null);
          append($$anchor3, fragment_1);
        }),
        $$slots: { default: true }
      });
      append($$anchor2, fragment);
    },
    ($$anchor2) => {
      var fragment_2 = comment();
      var node_3 = first_child(fragment_2);
      slot(node_3, $$props, "default", {}, null);
      append($$anchor2, fragment_2);
    }
  );
  reset(nav);
  template_effect(() => attributes = set_attributes(nav, attributes, {
    ...$$restProps,
    class: get(classes),
    "data-bs-theme": get(theme)
  }));
  append($$anchor, nav);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Navbar = hmr(Navbar, () => Navbar[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Navbar[HMR].source;
    set(Navbar[HMR].source, module.default[HMR].original);
  });
}
var Navbar_default = Navbar;
mark_module_end(Navbar);

// ../node_modules/sveltestrap/src/NavItem.svelte
mark_module_start();
NavItem[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/NavItem.svelte";
var root48 = add_locations(template(`<li><!></li>`), NavItem[FILENAME], [[11, 0]]);
function NavItem($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class", "active"]);
  push($$props, false, NavItem);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  let active = prop($$props, "active", 8, false);
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(active())),
    () => {
      set(classes, classnames(className(), "nav-item", active() ? "active" : false));
    }
  );
  legacy_pre_effect_reset();
  init();
  var li = root48();
  let attributes;
  var node = child(li);
  slot(node, $$props, "default", {}, null);
  reset(li);
  template_effect(() => attributes = set_attributes(li, attributes, { ...$$restProps, class: get(classes) }));
  append($$anchor, li);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  NavItem = hmr(NavItem, () => NavItem[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = NavItem[HMR].source;
    set(NavItem[HMR].source, module.default[HMR].original);
  });
}
var NavItem_default = NavItem;
mark_module_end(NavItem);

// ../node_modules/sveltestrap/src/NavLink.svelte
mark_module_start();
NavLink[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/NavLink.svelte";
var root49 = add_locations(template(`<a><!></a>`), NavLink[FILENAME], [[28, 0]]);
function NavLink($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class", "disabled", "active", "href"]);
  push($$props, false, NavLink);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  let disabled = prop($$props, "disabled", 8, false);
  let active = prop($$props, "active", 8, false);
  let href = prop($$props, "href", 8, "#");
  function handleClick(e) {
    if (disabled()) {
      e.preventDefault();
      e.stopImmediatePropagation();
      return;
    }
    if (strict_equals(href(), "#")) {
      e.preventDefault();
    }
  }
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(disabled()), deep_read_state(active())),
    () => {
      set(classes, classnames(className(), "nav-link", {
        disabled: disabled(),
        active: active()
      }));
    }
  );
  legacy_pre_effect_reset();
  init();
  var a = root49();
  let attributes;
  var node = child(a);
  slot(node, $$props, "default", {}, null);
  reset(a);
  template_effect(() => attributes = set_attributes(a, attributes, {
    ...$$restProps,
    href: href(),
    class: get(classes)
  }));
  event("click", a, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  event("click", a, handleClick);
  append($$anchor, a);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  NavLink = hmr(NavLink, () => NavLink[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = NavLink[HMR].source;
    set(NavLink[HMR].source, module.default[HMR].original);
  });
}
var NavLink_default = NavLink;
mark_module_end(NavLink);

// ../node_modules/sveltestrap/src/NavbarBrand.svelte
mark_module_start();
NavbarBrand[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/NavbarBrand.svelte";
var root50 = add_locations(template(`<a><!></a>`), NavbarBrand[FILENAME], [[11, 0]]);
function NavbarBrand($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class", "href"]);
  push($$props, false, NavbarBrand);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  let href = prop($$props, "href", 8, "/");
  legacy_pre_effect(
    () => (classnames, deep_read_state(className())),
    () => {
      set(classes, classnames(className(), "navbar-brand"));
    }
  );
  legacy_pre_effect_reset();
  init();
  var a = root50();
  let attributes;
  var node = child(a);
  slot(node, $$props, "default", {}, null);
  reset(a);
  template_effect(() => attributes = set_attributes(a, attributes, {
    ...$$restProps,
    class: get(classes),
    href: href()
  }));
  event("click", a, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, a);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  NavbarBrand = hmr(NavbarBrand, () => NavbarBrand[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = NavbarBrand[HMR].source;
    set(NavbarBrand[HMR].source, module.default[HMR].original);
  });
}
var NavbarBrand_default = NavbarBrand;
mark_module_end(NavbarBrand);

// ../node_modules/sveltestrap/src/NavbarToggler.svelte
mark_module_start();
NavbarToggler[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/NavbarToggler.svelte";
var root_120 = add_locations(template(`<span class="navbar-toggler-icon"></span>`), NavbarToggler[FILENAME], [[12, 4]]);
var root51 = add_locations(template(`<button><!></button>`), NavbarToggler[FILENAME], [[10, 0]]);
function NavbarToggler($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class"]);
  push($$props, false, NavbarToggler);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  legacy_pre_effect(
    () => (classnames, deep_read_state(className())),
    () => {
      set(classes, classnames(className(), "navbar-toggler"));
    }
  );
  legacy_pre_effect_reset();
  init();
  var button = root51();
  let attributes;
  var node = child(button);
  slot(node, $$props, "default", {}, ($$anchor2) => {
    var span = root_120();
    append($$anchor2, span);
  });
  reset(button);
  template_effect(() => attributes = set_attributes(button, attributes, { ...$$restProps, class: get(classes) }));
  event("click", button, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, button);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  NavbarToggler = hmr(NavbarToggler, () => NavbarToggler[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = NavbarToggler[HMR].source;
    set(NavbarToggler[HMR].source, module.default[HMR].original);
  });
}
var NavbarToggler_default = NavbarToggler;
mark_module_end(NavbarToggler);

// ../node_modules/sveltestrap/src/OffcanvasBackdrop.svelte
mark_module_start();
OffcanvasBackdrop[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/OffcanvasBackdrop.svelte";
var root_121 = add_locations(template(`<div></div>`), OffcanvasBackdrop[FILENAME], [[13, 2]]);
function OffcanvasBackdrop($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class", "isOpen", "fade"]);
  push($$props, false, OffcanvasBackdrop);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  let isOpen = prop($$props, "isOpen", 8, false);
  let fade2 = prop($$props, "fade", 8, true);
  legacy_pre_effect(
    () => (classnames, deep_read_state(className())),
    () => {
      set(classes, classnames(className(), "offcanvas-backdrop"));
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(node, isOpen, ($$anchor2) => {
    var div = root_121();
    let attributes;
    template_effect(() => {
      attributes = set_attributes(div, attributes, {
        role: "presentation",
        ...$$restProps,
        class: get(classes)
      });
      toggle_class(div, "fade", fade2());
    });
    event("click", div, function($$arg) {
      bubble_event.call(this, $$props, $$arg);
    });
    transition(1, div, () => backdropIn);
    transition(2, div, () => backdropOut);
    append($$anchor2, div);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  OffcanvasBackdrop = hmr(OffcanvasBackdrop, () => OffcanvasBackdrop[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = OffcanvasBackdrop[HMR].source;
    set(OffcanvasBackdrop[HMR].source, module.default[HMR].original);
  });
}
var OffcanvasBackdrop_default = OffcanvasBackdrop;
mark_module_end(OffcanvasBackdrop);

// ../node_modules/sveltestrap/src/OffcanvasBody.svelte
mark_module_start();
OffcanvasBody[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/OffcanvasBody.svelte";
var root52 = add_locations(template(`<div><!></div>`), OffcanvasBody[FILENAME], [[10, 0]]);
function OffcanvasBody($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class"]);
  push($$props, false, OffcanvasBody);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  legacy_pre_effect(
    () => (classnames, deep_read_state(className())),
    () => {
      set(classes, classnames(className(), "offcanvas-body"));
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root52();
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  template_effect(() => attributes = set_attributes(div, attributes, { ...$$restProps, class: get(classes) }));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  OffcanvasBody = hmr(OffcanvasBody, () => OffcanvasBody[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = OffcanvasBody[HMR].source;
    set(OffcanvasBody[HMR].source, module.default[HMR].original);
  });
}
var OffcanvasBody_default = OffcanvasBody;
mark_module_end(OffcanvasBody);

// ../node_modules/sveltestrap/src/OffcanvasHeader.svelte
mark_module_start();
OffcanvasHeader[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/OffcanvasHeader.svelte";
var root_49 = add_locations(template(`<button class="btn-close" type="button"></button>`), OffcanvasHeader[FILENAME], [[23, 6]]);
var root53 = add_locations(template(`<div><h5 class="offcanvas-title"><!></h5> <!></div>`), OffcanvasHeader[FILENAME], [[13, 0, [[14, 2]]]]);
function OffcanvasHeader($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "class",
    "children",
    "closeAriaLabel",
    "toggle"
  ]);
  push($$props, false, OffcanvasHeader);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  let children = prop($$props, "children", 8, void 0);
  let closeAriaLabel = prop($$props, "closeAriaLabel", 8, "Close");
  let toggle = prop($$props, "toggle", 8, void 0);
  legacy_pre_effect(
    () => (classnames, deep_read_state(className())),
    () => {
      set(classes, classnames(className(), "offcanvas-header"));
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root53();
  let attributes;
  var h5 = child(div);
  var node = child(h5);
  if_block(
    node,
    children,
    ($$anchor2) => {
      var text2 = text();
      template_effect(() => set_text(text2, children()));
      append($$anchor2, text2);
    },
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, $$props, "default", {}, null);
      append($$anchor2, fragment_1);
    }
  );
  reset(h5);
  var node_2 = sibling(h5, 2);
  slot(node_2, $$props, "close", {}, ($$anchor2) => {
    var fragment_2 = comment();
    var node_3 = first_child(fragment_2);
    if_block(node_3, () => strict_equals(typeof toggle(), "function"), ($$anchor3) => {
      var button = root_49();
      template_effect(() => set_attribute(button, "aria-label", closeAriaLabel()));
      event("click", button, function(...$$args) {
        apply(toggle, this, $$args, OffcanvasHeader, [26, 18]);
      });
      append($$anchor3, button);
    });
    append($$anchor2, fragment_2);
  });
  reset(div);
  template_effect(() => attributes = set_attributes(div, attributes, { ...$$restProps, class: get(classes) }));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  OffcanvasHeader = hmr(OffcanvasHeader, () => OffcanvasHeader[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = OffcanvasHeader[HMR].source;
    set(OffcanvasHeader[HMR].source, module.default[HMR].original);
  });
}
var OffcanvasHeader_default = OffcanvasHeader;
mark_module_end(OffcanvasHeader);

// ../node_modules/sveltestrap/src/Offcanvas.svelte
mark_module_start();
Offcanvas[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/Offcanvas.svelte";
var root_311 = add_locations(template(`<!> <!>`, 1), Offcanvas[FILENAME], []);
var root_122 = add_locations(template(`<div><!> <!></div> <!>`, 1), Offcanvas[FILENAME], [[94, 2]]);
var $$css2 = {
  hash: "s-oJpk4vQhn-IF",
  code: "\n  .overflow-noscroll {\n    overflow: hidden;\n    padding-right: 0px;\n  }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiT2ZmY2FudmFzLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiO0FBaUlBLEVBQVUsa0JBQW1CLENBQUM7QUFDOUIsSUFBSSxnQkFBZ0I7QUFDcEIsSUFBSSxrQkFBa0I7QUFDdEIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIk9mZmNhbnZhcy5zdmVsdGUiXX0= */"
};
function Offcanvas($$anchor, $$props) {
  check_target(new.target);
  const $$slots = sanitize_slots($$props);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "class",
    "backdrop",
    "body",
    "container",
    "fade",
    "header",
    "isOpen",
    "placement",
    "scroll",
    "sm",
    "md",
    "lg",
    "xl",
    "xxl",
    "style",
    "toggle"
  ]);
  push($$props, false, Offcanvas);
  append_styles($$anchor, $$css2);
  const handleMouseDown = mutable_state();
  const classes = mutable_state();
  const outer = mutable_state();
  const dispatch = createEventDispatcher();
  let className = prop($$props, "class", 8, "");
  let backdrop = prop($$props, "backdrop", 8, true);
  let body = prop($$props, "body", 8, true);
  let container = prop($$props, "container", 8, "body");
  let fade2 = prop($$props, "fade", 8, true);
  let header = prop($$props, "header", 8, void 0);
  let isOpen = prop($$props, "isOpen", 12, false);
  let placement = prop($$props, "placement", 8, "start");
  let scroll = prop($$props, "scroll", 8, false);
  let sm = prop($$props, "sm", 8, false);
  let md = prop($$props, "md", 8, false);
  let lg = prop($$props, "lg", 8, false);
  let xl = prop($$props, "xl", 8, false);
  let xxl = prop($$props, "xxl", 8, false);
  let style = prop($$props, "style", 8, "");
  let toggle = prop($$props, "toggle", 8, void 0);
  let bodyElement = mutable_state();
  let isTransitioning = mutable_state(false);
  let element = mutable_state();
  let removeEscListener = mutable_state();
  onMount(() => set(bodyElement, document.body));
  legacy_pre_effect(
    () => (get(element), deep_read_state(isOpen()), getTransitionDuration),
    () => {
      if (get(element)) {
        isOpen(isOpen());
        set(isTransitioning, true);
        dispatch(isOpen() ? "opening" : "closing");
        setTimeout(
          () => {
            set(isTransitioning, false);
            dispatch(isOpen() ? "open" : "close");
          },
          getTransitionDuration(get(element))
        );
      }
    }
  );
  legacy_pre_effect(
    () => (get(bodyElement), deep_read_state(scroll()), deep_read_state(isOpen()), get(isTransitioning)),
    () => {
      if (get(bodyElement)) {
        if (!scroll()) {
          get(bodyElement).classList.toggle("overflow-noscroll", isOpen() || get(isTransitioning));
        }
      }
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(isOpen()), deep_read_state(toggle()), browserEvent),
    () => {
      if (isOpen() && toggle() && strict_equals(typeof window, "undefined", false)) {
        set(removeEscListener, browserEvent(document, "keydown", (event2) => {
          if (event2.key && strict_equals(event2.key, "Escape")) toggle()();
        }));
      }
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(isOpen()), get(removeEscListener)),
    () => {
      if (!isOpen() && get(removeEscListener)) {
        get(removeEscListener)();
      }
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(backdrop()), deep_read_state(toggle()), get(bodyElement), deep_read_state(isOpen())),
    () => {
      set(handleMouseDown, backdrop() && toggle() && get(bodyElement) && isOpen() ? (e) => {
        if (strict_equals(e.target, get(bodyElement))) {
          toggle()();
        }
      } : void 0);
    }
  );
  legacy_pre_effect(
    () => (classnames, deep_read_state(sm()), deep_read_state(md()), deep_read_state(lg()), deep_read_state(xl()), deep_read_state(xxl()), deep_read_state(isOpen()), deep_read_state(placement()), deep_read_state(className())),
    () => {
      set(classes, classnames(
        {
          offcanvas: !sm() && !md() && !lg() && !xl() && !xxl(),
          "offcanvas-sm": sm(),
          "offcanvas-md": md(),
          "offcanvas-lg": lg(),
          "offcanvas-xl": xl(),
          "offcanvas-xxl": xxl(),
          show: isOpen()
        },
        `offcanvas-${placement()}`,
        className()
      ));
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(container()), InlineContainer_default, Portal_default),
    () => {
      set(outer, strict_equals(container(), "inline") ? InlineContainer_default : Portal_default);
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  event("mousedown", $document.body, function(...$$args) {
    apply(() => get(handleMouseDown), this, $$args, Offcanvas, [91, 27]);
  });
  var node = first_child(fragment);
  component(node, () => get(outer), ($$anchor2, $$component) => {
    $$component($$anchor2, {
      children: wrap_snippet(Offcanvas, ($$anchor3, $$slotProps) => {
        var fragment_1 = root_122();
        var div = first_child(fragment_1);
        let attributes;
        var node_1 = child(div);
        if_block(node_1, () => toggle() || header() || $$slots.header, ($$anchor4) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          OffcanvasHeader_default(node_2, {
            get toggle() {
              return toggle();
            },
            children: wrap_snippet(Offcanvas, ($$anchor5, $$slotProps2) => {
              var fragment_3 = root_311();
              var node_3 = first_child(fragment_3);
              if_block(node_3, header, ($$anchor6) => {
                var text2 = text();
                template_effect(() => set_text(text2, header()));
                append($$anchor6, text2);
              });
              var node_4 = sibling(node_3, 2);
              slot(node_4, $$props, "header", {}, null);
              append($$anchor5, fragment_3);
            }),
            $$slots: { default: true }
          });
          append($$anchor4, fragment_2);
        });
        var node_5 = sibling(node_1, 2);
        if_block(
          node_5,
          body,
          ($$anchor4) => {
            var fragment_5 = comment();
            var node_6 = first_child(fragment_5);
            OffcanvasBody_default(node_6, {
              children: wrap_snippet(Offcanvas, ($$anchor5, $$slotProps2) => {
                var fragment_6 = comment();
                var node_7 = first_child(fragment_6);
                slot(node_7, $$props, "default", {}, null);
                append($$anchor5, fragment_6);
              }),
              $$slots: { default: true }
            });
            append($$anchor4, fragment_5);
          },
          ($$anchor4) => {
            var fragment_7 = comment();
            var node_8 = first_child(fragment_7);
            slot(node_8, $$props, "default", {}, null);
            append($$anchor4, fragment_7);
          }
        );
        reset(div);
        bind_this(div, ($$value) => set(element, $$value), () => get(element));
        var node_9 = sibling(div, 2);
        if_block(node_9, backdrop, ($$anchor4) => {
          var fragment_8 = comment();
          var node_10 = first_child(fragment_8);
          var event_handler = derived(() => toggle() ? () => toggle()() : void 0);
          OffcanvasBackdrop_default(node_10, {
            get fade() {
              return fade2();
            },
            get isOpen() {
              return isOpen();
            },
            $$events: {
              click(...$$args) {
                apply(() => get(event_handler), this, $$args, Offcanvas, [122, 16]);
              }
            }
          });
          append($$anchor4, fragment_8);
        });
        template_effect(() => attributes = set_attributes(
          div,
          attributes,
          {
            ...$$restProps,
            "aria-hidden": !isOpen() ? true : void 0,
            "aria-modal": isOpen() ? true : void 0,
            class: get(classes),
            role: isOpen() || get(isTransitioning) ? "dialog" : void 0,
            style: `visibility: ${isOpen() || get(isTransitioning) ? "visible" : "hidden"};${style()}`,
            tabindex: "-1"
          },
          "s-oJpk4vQhn-IF"
        ));
        append($$anchor3, fragment_1);
      }),
      $$slots: { default: true }
    });
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Offcanvas = hmr(Offcanvas, () => Offcanvas[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-oJpk4vQhn-IF");
    module.default[HMR].source = Offcanvas[HMR].source;
    set(Offcanvas[HMR].source, module.default[HMR].original);
  });
}
var Offcanvas_default = Offcanvas;
mark_module_end(Offcanvas);

// ../node_modules/sveltestrap/src/Pagination.svelte
mark_module_start();
Pagination[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/Pagination.svelte";
var root54 = add_locations(template(`<nav><ul><!></ul></nav>`), Pagination[FILENAME], [[17, 0, [[18, 2]]]]);
function Pagination($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "class",
    "listClassName",
    "size",
    "ariaLabel"
  ]);
  push($$props, false, Pagination);
  const classes = mutable_state();
  const listClasses = mutable_state();
  let className = prop($$props, "class", 8, "");
  let listClassName = prop($$props, "listClassName", 8, "");
  let size = prop($$props, "size", 8, "");
  let ariaLabel = prop($$props, "ariaLabel", 8, "pagination");
  legacy_pre_effect(
    () => (classnames, deep_read_state(className())),
    () => {
      set(classes, classnames(className()));
    }
  );
  legacy_pre_effect(
    () => (classnames, deep_read_state(listClassName()), deep_read_state(size())),
    () => {
      set(listClasses, classnames(listClassName(), "pagination", { [`pagination-${size()}`]: !!size() }));
    }
  );
  legacy_pre_effect_reset();
  init();
  var nav = root54();
  let attributes;
  var ul = child(nav);
  var node = child(ul);
  slot(node, $$props, "default", {}, null);
  reset(ul);
  reset(nav);
  template_effect(() => {
    attributes = set_attributes(nav, attributes, {
      ...$$restProps,
      class: get(classes),
      "aria-label": ariaLabel()
    });
    set_class(ul, get(listClasses));
  });
  append($$anchor, nav);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Pagination = hmr(Pagination, () => Pagination[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Pagination[HMR].source;
    set(Pagination[HMR].source, module.default[HMR].original);
  });
}
var Pagination_default = Pagination;
mark_module_end(Pagination);

// ../node_modules/sveltestrap/src/PaginationItem.svelte
mark_module_start();
PaginationItem[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/PaginationItem.svelte";
var root55 = add_locations(template(`<li><!></li>`), PaginationItem[FILENAME], [[15, 0]]);
function PaginationItem($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class", "active", "disabled"]);
  push($$props, false, PaginationItem);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  let active = prop($$props, "active", 8, false);
  let disabled = prop($$props, "disabled", 8, false);
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(active()), deep_read_state(disabled())),
    () => {
      set(classes, classnames(className(), "page-item", {
        active: active(),
        disabled: disabled()
      }));
    }
  );
  legacy_pre_effect_reset();
  init();
  var li = root55();
  let attributes;
  var node = child(li);
  slot(node, $$props, "default", {}, null);
  reset(li);
  template_effect(() => attributes = set_attributes(li, attributes, { ...$$restProps, class: get(classes) }));
  append($$anchor, li);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  PaginationItem = hmr(PaginationItem, () => PaginationItem[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PaginationItem[HMR].source;
    set(PaginationItem[HMR].source, module.default[HMR].original);
  });
}
var PaginationItem_default = PaginationItem;
mark_module_end(PaginationItem);

// ../node_modules/sveltestrap/src/PaginationLink.svelte
mark_module_start();
PaginationLink[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/PaginationLink.svelte";
var root_123 = add_locations(template(`<span aria-hidden="true"><!></span> <span class="visually-hidden"> </span>`, 1), PaginationLink[FILENAME], [[43, 4], [46, 4]]);
var root56 = add_locations(template(`<a><!></a>`), PaginationLink[FILENAME], [[41, 0]]);
function PaginationLink($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "class",
    "next",
    "previous",
    "first",
    "last",
    "ariaLabel",
    "href"
  ]);
  push($$props, false, PaginationLink);
  const classes = mutable_state();
  const realLabel = mutable_state();
  let className = prop($$props, "class", 8, "");
  let next2 = prop($$props, "next", 8, false);
  let previous = prop($$props, "previous", 8, false);
  let first = prop($$props, "first", 8, false);
  let last = prop($$props, "last", 8, false);
  let ariaLabel = prop($$props, "ariaLabel", 8, "");
  let href = prop($$props, "href", 8, "");
  let defaultAriaLabel = mutable_state();
  let defaultCaret = mutable_state();
  legacy_pre_effect(
    () => (classnames, deep_read_state(className())),
    () => {
      set(classes, classnames(className(), "page-link"));
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(previous()), deep_read_state(next2()), deep_read_state(first()), deep_read_state(last())),
    () => {
      if (previous()) {
        set(defaultAriaLabel, "Previous");
      } else if (next2()) {
        set(defaultAriaLabel, "Next");
      } else if (first()) {
        set(defaultAriaLabel, "First");
      } else if (last()) {
        set(defaultAriaLabel, "Last");
      }
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(ariaLabel()), get(defaultAriaLabel)),
    () => {
      set(realLabel, ariaLabel() || get(defaultAriaLabel));
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(previous()), deep_read_state(next2()), deep_read_state(first()), deep_read_state(last())),
    () => {
      if (previous()) {
        set(defaultCaret, "‹");
      } else if (next2()) {
        set(defaultCaret, "›");
      } else if (first()) {
        set(defaultCaret, "«");
      } else if (last()) {
        set(defaultCaret, "»");
      }
    }
  );
  legacy_pre_effect_reset();
  init();
  var a = root56();
  let attributes;
  var node = child(a);
  if_block(
    node,
    () => previous() || next2() || first() || last(),
    ($$anchor2) => {
      var fragment = root_123();
      var span = first_child(fragment);
      var node_1 = child(span);
      slot(node_1, $$props, "default", {}, ($$anchor3) => {
        var text2 = text();
        template_effect(() => set_text(text2, get(defaultCaret)));
        append($$anchor3, text2);
      });
      reset(span);
      var span_1 = sibling(span, 2);
      var text_1 = child(span_1, true);
      reset(span_1);
      template_effect(() => set_text(text_1, get(realLabel)));
      append($$anchor2, fragment);
    },
    ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      slot(node_2, $$props, "default", {}, null);
      append($$anchor2, fragment_2);
    }
  );
  reset(a);
  template_effect(() => attributes = set_attributes(a, attributes, {
    ...$$restProps,
    class: get(classes),
    href: href()
  }));
  event("click", a, function($$arg) {
    bubble_event.call(this, $$props, $$arg);
  });
  append($$anchor, a);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  PaginationLink = hmr(PaginationLink, () => PaginationLink[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PaginationLink[HMR].source;
    set(PaginationLink[HMR].source, module.default[HMR].original);
  });
}
var PaginationLink_default = PaginationLink;
mark_module_end(PaginationLink);

// ../node_modules/sveltestrap/src/Popover.svelte
mark_module_start();
Popover[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/Popover.svelte";
var root_211 = add_locations(template(`<div><div class="popover-arrow" data-popper-arrow=""></div> <h3 class="popover-header"><!></h3> <div class="popover-body"><!></div></div>`), Popover[FILENAME], [
  [
    117,
    4,
    [[124, 6], [125, 6], [128, 6]]
  ]
]);
function Popover($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "class",
    "animation",
    "children",
    "container",
    "dismissible",
    "isOpen",
    "placement",
    "target",
    "title",
    "trigger"
  ]);
  push($$props, false, Popover);
  const classes = mutable_state();
  const outer = mutable_state();
  let className = prop($$props, "class", 8, "");
  let animation = prop($$props, "animation", 8, true);
  let children = prop($$props, "children", 8, void 0);
  let container = prop($$props, "container", 8, void 0);
  let dismissible = prop($$props, "dismissible", 8, false);
  let isOpen = prop($$props, "isOpen", 12, false);
  let placement = prop($$props, "placement", 8, "top");
  let target = prop($$props, "target", 8, "");
  let title = prop($$props, "title", 8, "");
  let trigger = prop($$props, "trigger", 8, "click");
  let targetEl = mutable_state();
  let popoverEl = mutable_state();
  let popperInstance = mutable_state();
  let bsPlacement = mutable_state();
  let popperPlacement = mutable_state(placement());
  const checkPopperPlacement = {
    name: "checkPopperPlacement",
    enabled: true,
    phase: "main",
    fn({ state }) {
      set(popperPlacement, state.placement);
    }
  };
  const open = () => isOpen(true);
  const close = () => isOpen(false);
  const toggle = () => isOpen(!isOpen());
  onMount(() => {
    set(targetEl, document.querySelector(`#${target()}`));
    switch (trigger()) {
      case "hover":
        get(targetEl).addEventListener("mouseover", open);
        get(targetEl).addEventListener("mouseleave", close);
        break;
      case "focus":
        get(targetEl).addEventListener("focus", open);
        get(targetEl).addEventListener("blur", close);
        break;
      default:
        get(targetEl).addEventListener("click", toggle);
        if (dismissible()) get(targetEl).addEventListener("blur", close);
        break;
    }
    return () => {
      switch (trigger()) {
        case "hover":
          get(targetEl).removeEventListener("mouseover", open);
          get(targetEl).removeEventListener("mouseleave", close);
          break;
        case "focus":
          get(targetEl).removeEventListener("focus", open);
          get(targetEl).removeEventListener("blur", close);
          break;
        default:
          get(targetEl).removeEventListener("click", toggle);
          if (dismissible()) get(targetEl).removeEventListener("blur", close);
          break;
      }
    };
  });
  legacy_pre_effect(
    () => (deep_read_state(isOpen()), get(popoverEl), get(popperInstance), createPopper3, get(targetEl), deep_read_state(placement())),
    () => {
      if (isOpen() && get(popoverEl)) {
        set(popperInstance, createPopper3(get(targetEl), get(popoverEl), {
          placement: placement(),
          modifiers: [
            checkPopperPlacement,
            {
              name: "offset",
              options: {
                offset: () => {
                  return [0, 8];
                }
              }
            }
          ]
        }));
      } else if (get(popperInstance)) {
        get(popperInstance).destroy();
        set(popperInstance, void 0);
      }
    }
  );
  legacy_pre_effect(() => deep_read_state(target()), () => {
    if (!target()) {
      throw new Error("Need target!");
    }
  });
  legacy_pre_effect(() => get(popperPlacement), () => {
    if (strict_equals(get(popperPlacement), "left")) set(bsPlacement, "start");
    else if (strict_equals(get(popperPlacement), "right")) set(bsPlacement, "end");
    else set(bsPlacement, get(popperPlacement));
  });
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(animation()), get(bsPlacement), deep_read_state(isOpen())),
    () => {
      set(classes, classnames(className(), "popover", animation() ? "fade" : false, `bs-popover-${get(bsPlacement)}`, isOpen() ? "show" : false));
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(container()), InlineContainer_default, Portal_default),
    () => {
      set(outer, strict_equals(container(), "inline") ? InlineContainer_default : Portal_default);
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(node, isOpen, ($$anchor2) => {
    var fragment_1 = comment();
    var node_1 = first_child(fragment_1);
    component(node_1, () => get(outer), ($$anchor3, $$component) => {
      $$component($$anchor3, {
        children: wrap_snippet(Popover, ($$anchor4, $$slotProps) => {
          var div = root_211();
          let attributes;
          var h3 = sibling(child(div), 2);
          var node_2 = child(h3);
          slot(node_2, $$props, "title", {}, ($$anchor5) => {
            var text2 = text();
            template_effect(() => set_text(text2, title()));
            append($$anchor5, text2);
          });
          reset(h3);
          var div_1 = sibling(h3, 2);
          var node_3 = child(div_1);
          if_block(
            node_3,
            children,
            ($$anchor5) => {
              var text_1 = text();
              template_effect(() => set_text(text_1, children()));
              append($$anchor5, text_1);
            },
            ($$anchor5) => {
              var fragment_4 = comment();
              var node_4 = first_child(fragment_4);
              slot(node_4, $$props, "default", {}, null);
              append($$anchor5, fragment_4);
            }
          );
          reset(div_1);
          reset(div);
          bind_this(div, ($$value) => set(popoverEl, $$value), () => get(popoverEl));
          template_effect(() => attributes = set_attributes(div, attributes, {
            ...$$restProps,
            class: get(classes),
            role: "tooltip",
            "x-placement": get(popperPlacement)
          }));
          append($$anchor4, div);
        }),
        $$slots: { default: true }
      });
    });
    append($$anchor2, fragment_1);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Popover = hmr(Popover, () => Popover[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Popover[HMR].source;
    set(Popover[HMR].source, module.default[HMR].original);
  });
}
var Popover_default = Popover;
mark_module_end(Popover);

// ../node_modules/sveltestrap/src/Progress.svelte
mark_module_start();
Progress[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/Progress.svelte";
var root_312 = add_locations(template(`<div><!></div>`), Progress[FILENAME], [[32, 4]]);
var root_64 = add_locations(template(`<div role="progressbar" aria-valuemin="0"><!></div>`), Progress[FILENAME], [[49, 6]]);
var root_410 = add_locations(template(`<div><!></div>`), Progress[FILENAME], [[45, 2]]);
function Progress($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "class",
    "bar",
    "multi",
    "value",
    "max",
    "animated",
    "striped",
    "color",
    "barClassName"
  ]);
  push($$props, false, Progress);
  const classes = mutable_state();
  const progressBarClasses = mutable_state();
  const percent = mutable_state();
  let className = prop($$props, "class", 8, "");
  let bar = prop($$props, "bar", 8, false);
  let multi = prop($$props, "multi", 8, false);
  let value = prop($$props, "value", 8, 0);
  let max2 = prop($$props, "max", 8, 100);
  let animated = prop($$props, "animated", 8, false);
  let striped = prop($$props, "striped", 8, false);
  let color = prop($$props, "color", 8, "");
  let barClassName = prop($$props, "barClassName", 8, "");
  legacy_pre_effect(
    () => (classnames, deep_read_state(className())),
    () => {
      set(classes, classnames(className(), "progress"));
    }
  );
  legacy_pre_effect(
    () => (classnames, deep_read_state(bar()), deep_read_state(className()), deep_read_state(barClassName()), deep_read_state(animated()), deep_read_state(color()), deep_read_state(striped())),
    () => {
      set(progressBarClasses, classnames("progress-bar", bar() ? className() || barClassName() : barClassName(), animated() ? "progress-bar-animated" : null, color() ? `text-bg-${color()}` : null, striped() || animated() ? "progress-bar-striped" : null));
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(value()), deep_read_state(max2())),
    () => {
      set(percent, parseInt(value(), 10) / parseInt(max2(), 10) * 100);
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    bar,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      if_block(
        node_1,
        multi,
        ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          slot(node_2, $$props, "default", {}, null);
          append($$anchor3, fragment_2);
        },
        ($$anchor3) => {
          var div = root_312();
          let attributes;
          var node_3 = child(div);
          slot(node_3, $$props, "default", {}, null);
          reset(div);
          template_effect(() => attributes = set_attributes(div, attributes, {
            ...$$restProps,
            class: get(progressBarClasses),
            style: `width: ${get(percent) ?? ""}%`,
            role: "progressbar",
            "aria-valuenow": value(),
            "aria-valuemin": "0",
            "aria-valuemax": max2()
          }));
          append($$anchor3, div);
        }
      );
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div_1 = root_410();
      let attributes_1;
      var node_4 = child(div_1);
      if_block(
        node_4,
        multi,
        ($$anchor3) => {
          var fragment_3 = comment();
          var node_5 = first_child(fragment_3);
          slot(node_5, $$props, "default", {}, null);
          append($$anchor3, fragment_3);
        },
        ($$anchor3) => {
          var div_2 = root_64();
          var node_6 = child(div_2);
          slot(node_6, $$props, "default", {}, null);
          reset(div_2);
          template_effect(() => {
            set_class(div_2, get(progressBarClasses));
            set_attribute(div_2, "style", `width: ${get(percent) ?? ""}%`);
            set_attribute(div_2, "aria-valuenow", value());
            set_attribute(div_2, "aria-valuemax", max2());
          });
          append($$anchor3, div_2);
        }
      );
      reset(div_1);
      template_effect(() => attributes_1 = set_attributes(div_1, attributes_1, { ...$$restProps, class: get(classes) }));
      append($$anchor2, div_1);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Progress = hmr(Progress, () => Progress[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Progress[HMR].source;
    set(Progress[HMR].source, module.default[HMR].original);
  });
}
var Progress_default = Progress;
mark_module_end(Progress);

// ../node_modules/sveltestrap/src/Row.svelte
mark_module_start();
Row[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/Row.svelte";
var root57 = add_locations(template(`<div><!></div>`), Row[FILENAME], [[41, 0]]);
function Row($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "class",
    "noGutters",
    "form",
    "cols",
    "inner"
  ]);
  push($$props, false, Row);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  let noGutters = prop($$props, "noGutters", 8, false);
  let form = prop($$props, "form", 8, false);
  let cols = prop($$props, "cols", 8, 0);
  let inner = prop($$props, "inner", 12, void 0);
  function getCols(cols2) {
    const colsValue = parseInt(cols2);
    if (!isNaN(colsValue)) {
      if (colsValue > 0) {
        return [`row-cols-${colsValue}`];
      }
    } else if (strict_equals(typeof cols2, "object")) {
      return ["xs", "sm", "md", "lg", "xl"].map((colWidth) => {
        const isXs = strict_equals(colWidth, "xs");
        const colSizeInterfix = isXs ? "-" : `-${colWidth}-`;
        const value = cols2[colWidth];
        if (strict_equals(typeof value, "number") && value > 0) {
          return `row-cols${colSizeInterfix}${value}`;
        }
        return null;
      }).filter((value) => !!value);
    }
    return [];
  }
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(noGutters()), deep_read_state(form()), deep_read_state(cols())),
    () => {
      set(classes, classnames(className(), noGutters() ? "gx-0" : null, form() ? "form-row" : "row", ...getCols(cols())));
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root57();
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  bind_this(div, ($$value) => inner($$value), () => inner());
  template_effect(() => attributes = set_attributes(div, attributes, { ...$$restProps, class: get(classes) }));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Row = hmr(Row, () => Row[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Row[HMR].source;
    set(Row[HMR].source, module.default[HMR].original);
  });
}
var Row_default = Row;
mark_module_end(Row);

// ../node_modules/sveltestrap/src/Spinner.svelte
mark_module_start();
Spinner[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/Spinner.svelte";
var root58 = add_locations(template(`<div><span class="visually-hidden"><!></span></div>`), Spinner[FILENAME], [[18, 0, [[19, 2]]]]);
function Spinner($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class", "type", "size", "color"]);
  push($$props, false, Spinner);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  let type = prop($$props, "type", 8, "border");
  let size = prop($$props, "size", 8, "");
  let color = prop($$props, "color", 8, "");
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(size()), deep_read_state(type()), deep_read_state(color())),
    () => {
      set(classes, classnames(className(), size() ? `spinner-${type()}-${size()}` : false, `spinner-${type()}`, color() ? `text-${color()}` : false));
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root58();
  let attributes;
  var span = child(div);
  var node = child(span);
  slot(node, $$props, "default", {}, ($$anchor2) => {
    var text2 = text("Loading...");
    append($$anchor2, text2);
  });
  reset(span);
  reset(div);
  template_effect(() => attributes = set_attributes(div, attributes, {
    ...$$restProps,
    role: "status",
    class: get(classes)
  }));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Spinner = hmr(Spinner, () => Spinner[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Spinner[HMR].source;
    set(Spinner[HMR].source, module.default[HMR].original);
  });
}
var Spinner_default = Spinner;
mark_module_end(Spinner);

// ../node_modules/sveltestrap/src/Styles.svelte
mark_module_start();
Styles[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/Styles.svelte";
var root_212 = add_locations(template(`<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">`), Styles[FILENAME], [[23, 4]]);
var root_124 = add_locations(template(`<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"> <!>`, 1), Styles[FILENAME], [[18, 2]]);
function Styles($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Styles);
  let icons = prop($$props, "icons", 8, true);
  let theme = prop($$props, "theme", 8, void 0);
  legacy_pre_effect(() => deep_read_state(theme()), () => {
    if (strict_equals(typeof document, "undefined", false) && strict_equals(theme(), void 0, false)) {
      if (strict_equals(theme(), "auto") && window.matchMedia("(prefers-color-scheme: dark)").matches) {
        document.documentElement.setAttribute("data-bs-theme", "dark");
      } else {
        document.documentElement.setAttribute("data-bs-theme", theme());
      }
    }
  });
  legacy_pre_effect_reset();
  init();
  head(($$anchor2) => {
    var fragment = root_124();
    var node = sibling(first_child(fragment), 2);
    if_block(node, icons, ($$anchor3) => {
      var link = root_212();
      append($$anchor3, link);
    });
    append($$anchor2, fragment);
  });
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Styles = hmr(Styles, () => Styles[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Styles[HMR].source;
    set(Styles[HMR].source, module.default[HMR].original);
  });
}
var Styles_default = Styles;
mark_module_end(Styles);

// ../node_modules/sveltestrap/src/Colgroup.svelte
mark_module_start();
Colgroup[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/Colgroup.svelte";
var root59 = add_locations(template(`<colgroup><!></colgroup>`), Colgroup[FILENAME], [[7, 0]]);
function Colgroup($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Colgroup);
  setContext("colgroup", true);
  init();
  var colgroup = root59();
  var node = child(colgroup);
  slot(node, $$props, "default", {}, null);
  reset(colgroup);
  append($$anchor, colgroup);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Colgroup = hmr(Colgroup, () => Colgroup[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Colgroup[HMR].source;
    set(Colgroup[HMR].source, module.default[HMR].original);
  });
}
var Colgroup_default = Colgroup;
mark_module_end(Colgroup);

// ../node_modules/sveltestrap/src/ResponsiveContainer.svelte
mark_module_start();
ResponsiveContainer[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/ResponsiveContainer.svelte";
var root_125 = add_locations(template(`<div><!></div>`), ResponsiveContainer[FILENAME], [[15, 2]]);
function ResponsiveContainer($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, ResponsiveContainer);
  const responsiveClassName = mutable_state();
  let className = prop($$props, "class", 8, "");
  let responsive = prop($$props, "responsive", 8, false);
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(responsive())),
    () => {
      set(responsiveClassName, classnames(className(), {
        "table-responsive": strict_equals(responsive(), true),
        [`table-responsive-${responsive()}`]: strict_equals(typeof responsive(), "string")
      }));
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    responsive,
    ($$anchor2) => {
      var div = root_125();
      var node_1 = child(div);
      slot(node_1, $$props, "default", {}, null);
      reset(div);
      template_effect(() => set_class(div, get(responsiveClassName)));
      append($$anchor2, div);
    },
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_2 = first_child(fragment_1);
      slot(node_2, $$props, "default", {}, null);
      append($$anchor2, fragment_1);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ResponsiveContainer = hmr(ResponsiveContainer, () => ResponsiveContainer[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ResponsiveContainer[HMR].source;
    set(ResponsiveContainer[HMR].source, module.default[HMR].original);
  });
}
var ResponsiveContainer_default = ResponsiveContainer;
mark_module_end(ResponsiveContainer);

// ../node_modules/sveltestrap/src/TableFooter.svelte
mark_module_start();
TableFooter[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/TableFooter.svelte";
var root60 = add_locations(template(`<tfoot><tr><!></tr></tfoot>`), TableFooter[FILENAME], [[7, 0, [[8, 2]]]]);
function TableFooter($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, []);
  push($$props, false, TableFooter);
  setContext("footer", true);
  init();
  var tfoot = root60();
  let attributes;
  var tr = child(tfoot);
  var node = child(tr);
  slot(node, $$props, "default", {}, null);
  reset(tr);
  reset(tfoot);
  template_effect(() => attributes = set_attributes(tfoot, attributes, { ...$$restProps }));
  append($$anchor, tfoot);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TableFooter = hmr(TableFooter, () => TableFooter[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TableFooter[HMR].source;
    set(TableFooter[HMR].source, module.default[HMR].original);
  });
}
var TableFooter_default = TableFooter;
mark_module_end(TableFooter);

// ../node_modules/sveltestrap/src/TableHeader.svelte
mark_module_start();
TableHeader[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/TableHeader.svelte";
var root61 = add_locations(template(`<thead><tr><!></tr></thead>`), TableHeader[FILENAME], [[7, 0, [[8, 2]]]]);
function TableHeader($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, []);
  push($$props, false, TableHeader);
  setContext("header", true);
  init();
  var thead = root61();
  let attributes;
  var tr = child(thead);
  var node = child(tr);
  slot(node, $$props, "default", {}, null);
  reset(tr);
  reset(thead);
  template_effect(() => attributes = set_attributes(thead, attributes, { ...$$restProps }));
  append($$anchor, thead);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TableHeader = hmr(TableHeader, () => TableHeader[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TableHeader[HMR].source;
    set(TableHeader[HMR].source, module.default[HMR].original);
  });
}
var TableHeader_default = TableHeader;
mark_module_end(TableHeader);

// ../node_modules/sveltestrap/src/Table.svelte
mark_module_start();
Table[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/Table.svelte";
var root_54 = add_locations(template(`<tr><!></tr>`), Table[FILENAME], [[40, 10]]);
var root_213 = add_locations(template(`<!> <!> <tbody></tbody> <!>`, 1), Table[FILENAME], [[38, 6]]);
var root_126 = add_locations(template(`<table><!></table>`), Table[FILENAME], [[30, 2]]);
function Table($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "class",
    "size",
    "bordered",
    "borderless",
    "striped",
    "hover",
    "responsive",
    "rows"
  ]);
  push($$props, false, Table);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  let size = prop($$props, "size", 8, "");
  let bordered = prop($$props, "bordered", 8, false);
  let borderless = prop($$props, "borderless", 8, false);
  let striped = prop($$props, "striped", 8, false);
  let hover = prop($$props, "hover", 8, false);
  let responsive = prop($$props, "responsive", 8, false);
  let rows = prop($$props, "rows", 8, void 0);
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(size()), deep_read_state(bordered()), deep_read_state(borderless()), deep_read_state(striped()), deep_read_state(hover())),
    () => {
      set(classes, classnames(className(), "table", size() ? "table-" + size() : false, bordered() ? "table-bordered" : false, borderless() ? "table-borderless" : false, striped() ? "table-striped" : false, hover() ? "table-hover" : false));
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  ResponsiveContainer_default(node, {
    get responsive() {
      return responsive();
    },
    children: wrap_snippet(Table, ($$anchor2, $$slotProps) => {
      var table = root_126();
      let attributes;
      var node_1 = child(table);
      if_block(
        node_1,
        rows,
        ($$anchor3) => {
          var fragment_1 = root_213();
          var node_2 = first_child(fragment_1);
          Colgroup_default(node_2, {
            children: wrap_snippet(Table, ($$anchor4, $$slotProps2) => {
              var fragment_2 = comment();
              var node_3 = first_child(fragment_2);
              slot(node_3, $$props, "default", {}, null);
              append($$anchor4, fragment_2);
            }),
            $$slots: { default: true }
          });
          var node_4 = sibling(node_2, 2);
          TableHeader_default(node_4, {
            children: wrap_snippet(Table, ($$anchor4, $$slotProps2) => {
              var fragment_3 = comment();
              var node_5 = first_child(fragment_3);
              slot(node_5, $$props, "default", {}, null);
              append($$anchor4, fragment_3);
            }),
            $$slots: { default: true }
          });
          var tbody = sibling(node_4, 2);
          each(tbody, 5, rows, index, ($$anchor4, row) => {
            var tr = root_54();
            var node_6 = child(tr);
            slot(
              node_6,
              $$props,
              "default",
              {
                get row() {
                  return get(row);
                }
              },
              null
            );
            reset(tr);
            append($$anchor4, tr);
          });
          reset(tbody);
          var node_7 = sibling(tbody, 2);
          TableFooter_default(node_7, {
            children: wrap_snippet(Table, ($$anchor4, $$slotProps2) => {
              var fragment_4 = comment();
              var node_8 = first_child(fragment_4);
              slot(node_8, $$props, "default", {}, null);
              append($$anchor4, fragment_4);
            }),
            $$slots: { default: true }
          });
          append($$anchor3, fragment_1);
        },
        ($$anchor3) => {
          var fragment_5 = comment();
          var node_9 = first_child(fragment_5);
          slot(node_9, $$props, "default", {}, null);
          append($$anchor3, fragment_5);
        }
      );
      reset(table);
      template_effect(() => attributes = set_attributes(table, attributes, { ...$$restProps, class: get(classes) }));
      append($$anchor2, table);
    }),
    $$slots: { default: true }
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Table = hmr(Table, () => Table[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Table[HMR].source;
    set(Table[HMR].source, module.default[HMR].original);
  });
}
var Table_default = Table;
mark_module_end(Table);

// ../node_modules/sveltestrap/src/TabHeader.svelte
mark_module_start();
TabHeader[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/TabHeader.svelte";
function TabHeader($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, []);
  push($$props, false, TabHeader);
  setContext("tabs", true);
  init();
  var fragment = comment();
  var node = first_child(fragment);
  Nav_default(node, spread_props(() => $$restProps, {
    children: wrap_snippet(TabHeader, ($$anchor2, $$slotProps) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      slot(node_1, $$props, "default", {}, null);
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  }));
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TabHeader = hmr(TabHeader, () => TabHeader[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TabHeader[HMR].source;
    set(TabHeader[HMR].source, module.default[HMR].original);
  });
}
var TabHeader_default = TabHeader;
mark_module_end(TabHeader);

// ../node_modules/sveltestrap/src/TabContent.svelte
mark_module_start();
TabContent[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/TabContent.svelte";
var root62 = add_locations(template(`<div><!> <!></div>`), TabContent[FILENAME], [[28, 0]]);
function TabContent($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class", "pills", "vertical"]);
  push($$props, false, TabContent);
  const classes = mutable_state();
  const dispatch = createEventDispatcher();
  let className = prop($$props, "class", 8, "");
  let pills = prop($$props, "pills", 8, false);
  let vertical = prop($$props, "vertical", 8, false);
  const activeTabId = writable();
  setContext("tabContent", {
    activeTabId,
    setActiveTab: (tabId) => {
      activeTabId.set(tabId);
      dispatch("tab", tabId);
    }
  });
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(vertical())),
    () => {
      set(classes, classnames("tab-content", className(), { "d-flex align-items-start": vertical() }));
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root62();
  let attributes;
  var node = child(div);
  var class_1 = derived_safe_equal(() => classnames({ "me-3": vertical() }));
  var tabs = derived_safe_equal(() => !pills());
  TabHeader_default(node, {
    get class() {
      return get(class_1);
    },
    get pills() {
      return pills();
    },
    get tabs() {
      return get(tabs);
    },
    get vertical() {
      return vertical();
    },
    children: wrap_snippet(TabContent, ($$anchor2, $$slotProps) => {
      var fragment = comment();
      var node_1 = first_child(fragment);
      slot(node_1, $$props, "default", {}, null);
      append($$anchor2, fragment);
    }),
    $$slots: { default: true }
  });
  var node_2 = sibling(node, 2);
  slot(node_2, $$props, "default", {}, null);
  reset(div);
  template_effect(() => attributes = set_attributes(div, attributes, { ...$$restProps, class: get(classes) }));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TabContent = hmr(TabContent, () => TabContent[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TabContent[HMR].source;
    set(TabContent[HMR].source, module.default[HMR].original);
  });
}
var TabContent_default = TabContent;
mark_module_end(TabContent);

// ../node_modules/sveltestrap/src/TabPane.svelte
mark_module_start();
TabPane[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/TabPane.svelte";
var root_313 = add_locations(template(`<!> <!>`, 1), TabPane[FILENAME], []);
var root_55 = add_locations(template(`<div><!></div>`), TabPane[FILENAME], [[37, 2]]);
function TabPane($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "class",
    "active",
    "disabled",
    "tab",
    "tabId"
  ]);
  push($$props, false, TabPane);
  const $$stores = setup_stores();
  const $activeTabId = () => (validate_store(activeTabId, "activeTabId"), store_get(activeTabId, "$activeTabId", $$stores));
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  let active = prop($$props, "active", 8, false);
  let disabled = prop($$props, "disabled", 8, false);
  let tab = prop($$props, "tab", 8, void 0);
  let tabId = prop($$props, "tabId", 8, void 0);
  const tabs = getContext("tabs");
  const { activeTabId, setActiveTab } = getContext("tabContent");
  onMount(() => {
    if (active()) setActiveTab(tabId());
  });
  let tabOpen = mutable_state(active());
  legacy_pre_effect(
    () => ($activeTabId(), deep_read_state(tabId())),
    () => {
      if (strict_equals($activeTabId(), void 0, false)) set(tabOpen, strict_equals($activeTabId(), tabId()));
    }
  );
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), get(tabOpen)),
    () => {
      set(classes, classnames("tab-pane", className(), {
        active: get(tabOpen),
        show: get(tabOpen)
      }));
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    () => tabs,
    ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      NavItem_default(node_1, {
        children: wrap_snippet(TabPane, ($$anchor3, $$slotProps) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          NavLink_default(node_2, {
            get active() {
              return get(tabOpen);
            },
            get disabled() {
              return disabled();
            },
            $$events: { click: () => setActiveTab(tabId()) },
            children: wrap_snippet(TabPane, ($$anchor4, $$slotProps2) => {
              var fragment_3 = root_313();
              var node_3 = first_child(fragment_3);
              if_block(node_3, tab, ($$anchor5) => {
                var text2 = text();
                template_effect(() => set_text(text2, tab()));
                append($$anchor5, text2);
              });
              var node_4 = sibling(node_3, 2);
              slot(node_4, $$props, "tab", {}, null);
              append($$anchor4, fragment_3);
            }),
            $$slots: { default: true }
          });
          append($$anchor3, fragment_2);
        }),
        $$slots: { default: true }
      });
      append($$anchor2, fragment_1);
    },
    ($$anchor2) => {
      var div = root_55();
      let attributes;
      var node_5 = child(div);
      slot(node_5, $$props, "default", {}, null);
      reset(div);
      template_effect(() => attributes = set_attributes(div, attributes, { ...$$restProps, class: get(classes) }));
      append($$anchor2, div);
    }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TabPane = hmr(TabPane, () => TabPane[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TabPane[HMR].source;
    set(TabPane[HMR].source, module.default[HMR].original);
  });
}
var TabPane_default = TabPane;
mark_module_end(TabPane);

// ../node_modules/sveltestrap/src/ToastBody.svelte
mark_module_start();
ToastBody[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/ToastBody.svelte";
var root63 = add_locations(template(`<div><!></div>`), ToastBody[FILENAME], [[10, 0]]);
function ToastBody($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class"]);
  push($$props, false, ToastBody);
  const classes = mutable_state();
  let className = prop($$props, "class", 8, "");
  legacy_pre_effect(
    () => (classnames, deep_read_state(className())),
    () => {
      set(classes, classnames(className(), "toast-body"));
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root63();
  let attributes;
  var node = child(div);
  slot(node, $$props, "default", {}, null);
  reset(div);
  template_effect(() => attributes = set_attributes(div, attributes, { ...$$restProps, class: get(classes) }));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ToastBody = hmr(ToastBody, () => ToastBody[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ToastBody[HMR].source;
    set(ToastBody[HMR].source, module.default[HMR].original);
  });
}
var ToastBody_default = ToastBody;
mark_module_end(ToastBody);

// ../node_modules/sveltestrap/src/ToastHeader.svelte
mark_module_start();
ToastHeader[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/ToastHeader.svelte";
var root_127 = add_locations(template(`<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid slice" focusable="false" role="img"><rect fill="currentColor" width="100%" height="100%"></rect></svg>`), ToastHeader[FILENAME], [[18, 4, [[27, 6]]]]);
var root64 = add_locations(template(`<div><!> <strong><!></strong> <!></div>`), ToastHeader[FILENAME], [[16, 0, [[32, 2]]]]);
function ToastHeader($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, ["class", "icon", "toggle", "closeAriaLabel"]);
  push($$props, false, ToastHeader);
  const classes = mutable_state();
  const tagClassName = mutable_state();
  let className = prop($$props, "class", 8, "");
  let icon = prop($$props, "icon", 8, null);
  let toggle = prop($$props, "toggle", 8, null);
  let closeAriaLabel = prop($$props, "closeAriaLabel", 8, "Close");
  legacy_pre_effect(
    () => (classnames, deep_read_state(className())),
    () => {
      set(classes, classnames(className(), "toast-header"));
    }
  );
  legacy_pre_effect(() => (classnames, deep_read_state(icon())), () => {
    set(tagClassName, classnames("me-auto", { "ms-2": equals(icon(), null, false) }));
  });
  legacy_pre_effect_reset();
  init();
  var div = root64();
  let attributes;
  var node = child(div);
  if_block(
    node,
    icon,
    ($$anchor2) => {
      var svg = root_127();
      template_effect(() => set_svg_class(svg, `rounded text-${icon()}`));
      append($$anchor2, svg);
    },
    ($$anchor2) => {
      var fragment = comment();
      var node_1 = first_child(fragment);
      slot(node_1, $$props, "icon", {}, null);
      append($$anchor2, fragment);
    }
  );
  var strong = sibling(node, 2);
  var node_2 = child(strong);
  slot(node_2, $$props, "default", {}, null);
  reset(strong);
  var node_3 = sibling(strong, 2);
  if_block(node_3, toggle, ($$anchor2) => {
    var fragment_1 = comment();
    var node_4 = first_child(fragment_1);
    slot(node_4, $$props, "close", {}, ($$anchor3) => {
      var fragment_2 = comment();
      var node_5 = first_child(fragment_2);
      Button_default(node_5, {
        close: true,
        get "aria-label"() {
          return closeAriaLabel();
        },
        $$events: {
          click(...$$args) {
            apply(toggle, this, $$args, ToastHeader, [37, 30]);
          }
        }
      });
      append($$anchor3, fragment_2);
    });
    append($$anchor2, fragment_1);
  });
  reset(div);
  template_effect(() => {
    attributes = set_attributes(div, attributes, { ...$$restProps, class: get(classes) });
    set_class(strong, get(tagClassName));
  });
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ToastHeader = hmr(ToastHeader, () => ToastHeader[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ToastHeader[HMR].source;
    set(ToastHeader[HMR].source, module.default[HMR].original);
  });
}
var ToastHeader_default = ToastHeader;
mark_module_end(ToastHeader);

// ../node_modules/sveltestrap/src/Toast.svelte
mark_module_start();
Toast[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/Toast.svelte";
var root_128 = add_locations(template(`<div><!> <!></div>`), Toast[FILENAME], [[37, 2]]);
function Toast($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "class",
    "autohide",
    "body",
    "delay",
    "duration",
    "fade",
    "header",
    "isOpen",
    "toggle"
  ]);
  push($$props, false, Toast);
  const classes = mutable_state();
  const dispatch = createEventDispatcher();
  let className = prop($$props, "class", 8, "");
  let autohide = prop($$props, "autohide", 8, false);
  let body = prop($$props, "body", 8, false);
  let delay = prop($$props, "delay", 8, 5e3);
  let duration = prop($$props, "duration", 8, 200);
  let fade2 = prop($$props, "fade", 8, true);
  let header = prop($$props, "header", 8, void 0);
  let isOpen = prop($$props, "isOpen", 12, true);
  let toggle = prop($$props, "toggle", 8, null);
  let timeout = mutable_state();
  onDestroy(() => {
    return () => clearTimeout(get(timeout));
  });
  legacy_pre_effect(
    () => (deep_read_state(isOpen()), deep_read_state(autohide()), deep_read_state(delay())),
    () => {
      if (isOpen() && autohide()) {
        set(timeout, setTimeout(() => isOpen(false), delay()));
      }
    }
  );
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(isOpen())),
    () => {
      set(classes, classnames(className(), "toast", { show: isOpen() }));
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(node, isOpen, ($$anchor2) => {
    var div = root_128();
    let attributes;
    var node_1 = child(div);
    if_block(node_1, header, ($$anchor3) => {
      var fragment_1 = comment();
      var node_2 = first_child(fragment_1);
      ToastHeader_default(node_2, {
        get toggle() {
          return toggle();
        },
        children: wrap_snippet(Toast, ($$anchor4, $$slotProps) => {
          next();
          var text2 = text();
          template_effect(() => set_text(text2, header()));
          append($$anchor4, text2);
        }),
        $$slots: { default: true }
      });
      append($$anchor3, fragment_1);
    });
    var node_3 = sibling(node_1, 2);
    if_block(
      node_3,
      body,
      ($$anchor3) => {
        var fragment_3 = comment();
        var node_4 = first_child(fragment_3);
        ToastBody_default(node_4, {
          children: wrap_snippet(Toast, ($$anchor4, $$slotProps) => {
            var fragment_4 = comment();
            var node_5 = first_child(fragment_4);
            slot(node_5, $$props, "default", {}, null);
            append($$anchor4, fragment_4);
          }),
          $$slots: { default: true }
        });
        append($$anchor3, fragment_3);
      },
      ($$anchor3) => {
        var fragment_5 = comment();
        var node_6 = first_child(fragment_5);
        slot(node_6, $$props, "default", {}, null);
        append($$anchor3, fragment_5);
      }
    );
    reset(div);
    template_effect(() => attributes = set_attributes(div, attributes, {
      ...$$restProps,
      class: get(classes),
      role: "alert"
    }));
    transition(3, div, () => fade, () => ({ duration: fade2() && duration() }));
    event("introstart", div, () => dispatch("opening"));
    event("introend", div, () => dispatch("open"));
    event("outrostart", div, () => dispatch("closing"));
    event("outroend", div, () => dispatch("close"));
    append($$anchor2, div);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Toast = hmr(Toast, () => Toast[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Toast[HMR].source;
    set(Toast[HMR].source, module.default[HMR].original);
  });
}
var Toast_default = Toast;
mark_module_end(Toast);

// ../node_modules/sveltestrap/src/Tooltip.svelte
mark_module_start();
Tooltip[FILENAME] = "/Users/jatinlalwani/Desktop/webpage-template/webpage-template/node_modules/sveltestrap/src/Tooltip.svelte";
var root_214 = add_locations(template(`<div><div class="tooltip-arrow" data-popper-arrow=""></div> <div class="tooltip-inner"><!></div></div>`), Tooltip[FILENAME], [
  [123, 4, [[131, 6], [132, 6]]]
]);
function Tooltip($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, [
    "class",
    "animation",
    "children",
    "container",
    "id",
    "isOpen",
    "placement",
    "target"
  ]);
  push($$props, false, Tooltip);
  const classes = mutable_state();
  const outer = mutable_state();
  let className = prop($$props, "class", 8, "");
  let animation = prop($$props, "animation", 8, true);
  let children = prop($$props, "children", 8, void 0);
  let container = prop($$props, "container", 8, void 0);
  let id = prop($$props, "id", 24, () => `tooltip_${uuid()}`);
  let isOpen = prop($$props, "isOpen", 12, false);
  let placement = prop($$props, "placement", 8, "top");
  let target = prop($$props, "target", 8, "");
  let bsPlacement = mutable_state();
  let popperInstance = mutable_state();
  let popperPlacement = mutable_state(placement());
  let targetEl = mutable_state();
  let tooltipEl = mutable_state();
  const checkPopperPlacement = {
    name: "checkPopperPlacement",
    enabled: true,
    phase: "main",
    fn({ state }) {
      set(popperPlacement, state.placement);
    }
  };
  const open = () => isOpen(true);
  const close = () => isOpen(false);
  onMount(registerEventListeners);
  onDestroy(unregisterEventListeners);
  function registerEventListeners() {
    if (equals(target(), null) || equals(target().length, 0)) {
      set(targetEl, null);
      return;
    }
    try {
      if (target() instanceof HTMLElement) {
        set(targetEl, target());
      }
    } catch (e) {
    }
    if (equals(get(targetEl), null)) {
      try {
        set(targetEl, document.querySelector(`#${target()}`));
      } catch (e) {
      }
    }
    if (get(targetEl)) {
      get(targetEl).addEventListener("mouseover", open);
      get(targetEl).addEventListener("mouseleave", close);
      get(targetEl).addEventListener("focus", open);
      get(targetEl).addEventListener("blur", close);
    }
  }
  function unregisterEventListeners() {
    if (get(targetEl)) {
      get(targetEl).removeEventListener("mouseover", open);
      get(targetEl).removeEventListener("mouseleave", close);
      get(targetEl).removeEventListener("focus", open);
      get(targetEl).removeEventListener("blur", close);
      get(targetEl).removeAttribute("aria-describedby");
    }
  }
  legacy_pre_effect(
    () => (deep_read_state(isOpen()), get(tooltipEl), get(popperInstance), createPopper3, get(targetEl), deep_read_state(placement())),
    () => {
      if (isOpen() && get(tooltipEl)) {
        set(popperInstance, createPopper3(get(targetEl), get(tooltipEl), {
          placement: placement(),
          modifiers: [checkPopperPlacement]
        }));
      } else if (get(popperInstance)) {
        get(popperInstance).destroy();
        set(popperInstance, void 0);
      }
    }
  );
  legacy_pre_effect(() => deep_read_state(target()), () => {
    if (target()) {
      unregisterEventListeners();
      registerEventListeners();
    }
  });
  legacy_pre_effect(
    () => (get(targetEl), deep_read_state(isOpen()), deep_read_state(id())),
    () => {
      if (get(targetEl)) {
        if (isOpen()) get(targetEl).setAttribute("aria-describedby", id());
        else get(targetEl).removeAttribute("aria-describedby");
      }
    }
  );
  legacy_pre_effect(() => get(popperPlacement), () => {
    if (strict_equals(get(popperPlacement), "left")) set(bsPlacement, "start");
    else if (strict_equals(get(popperPlacement), "right")) set(bsPlacement, "end");
    else set(bsPlacement, get(popperPlacement));
  });
  legacy_pre_effect(
    () => (classnames, deep_read_state(className()), deep_read_state(animation()), get(bsPlacement), deep_read_state(isOpen())),
    () => {
      set(classes, classnames(className(), "tooltip", animation() ? "fade" : false, `bs-tooltip-${get(bsPlacement)}`, isOpen() ? "show" : false));
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(container()), InlineContainer_default, Portal_default),
    () => {
      set(outer, strict_equals(container(), "inline") ? InlineContainer_default : Portal_default);
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(node, isOpen, ($$anchor2) => {
    var fragment_1 = comment();
    var node_1 = first_child(fragment_1);
    component(node_1, () => get(outer), ($$anchor3, $$component) => {
      $$component($$anchor3, {
        children: wrap_snippet(Tooltip, ($$anchor4, $$slotProps) => {
          var div = root_214();
          let attributes;
          var div_1 = sibling(child(div), 2);
          var node_2 = child(div_1);
          if_block(
            node_2,
            children,
            ($$anchor5) => {
              var text2 = text();
              template_effect(() => set_text(text2, children()));
              append($$anchor5, text2);
            },
            ($$anchor5) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              slot(node_3, $$props, "default", {}, null);
              append($$anchor5, fragment_3);
            }
          );
          reset(div_1);
          reset(div);
          bind_this(div, ($$value) => set(tooltipEl, $$value), () => get(tooltipEl));
          template_effect(() => attributes = set_attributes(div, attributes, {
            ...$$restProps,
            class: get(classes),
            id: id(),
            role: "tooltip",
            "x-placement": get(popperPlacement)
          }));
          append($$anchor4, div);
        }),
        $$slots: { default: true }
      });
    });
    append($$anchor2, fragment_1);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tooltip = hmr(Tooltip, () => Tooltip[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tooltip[HMR].source;
    set(Tooltip[HMR].source, module.default[HMR].original);
  });
}
var Tooltip_default = Tooltip;
mark_module_end(Tooltip);
export {
  Accordion_default as Accordion,
  AccordionHeader_default as AccordionHeader,
  AccordionItem_default as AccordionItem,
  Alert_default as Alert,
  Badge_default as Badge,
  Breadcrumb_default as Breadcrumb,
  BreadcrumbItem_default as BreadcrumbItem,
  Button_default as Button,
  ButtonDropdown_default as ButtonDropdown,
  ButtonGroup_default as ButtonGroup,
  ButtonToolbar_default as ButtonToolbar,
  Card_default as Card,
  CardBody_default as CardBody,
  CardColumns_default as CardColumns,
  CardDeck_default as CardDeck,
  CardFooter_default as CardFooter,
  CardGroup_default as CardGroup,
  CardHeader_default as CardHeader,
  CardImg_default as CardImg,
  CardImgOverlay_default as CardImgOverlay,
  CardLink_default as CardLink,
  CardSubtitle_default as CardSubtitle,
  CardText_default as CardText,
  CardTitle_default as CardTitle,
  Carousel_default as Carousel,
  CarouselCaption_default as CarouselCaption,
  CarouselControl_default as CarouselControl,
  CarouselIndicators_default as CarouselIndicators,
  CarouselItem_default as CarouselItem,
  Col_default as Col,
  Collapse_default as Collapse,
  Column_default as Column,
  Container_default as Container,
  Dropdown_default as Dropdown,
  DropdownItem_default as DropdownItem,
  DropdownMenu_default as DropdownMenu,
  DropdownToggle_default as DropdownToggle,
  Fade_default as Fade,
  Figure_default as Figure,
  Form_default as Form,
  FormCheck_default as FormCheck,
  FormFeedback_default as FormFeedback,
  FormGroup_default as FormGroup,
  FormText_default as FormText,
  Icon_default as Icon,
  Image_default as Image,
  InlineContainer_default as InlineContainer,
  Input_default as Input,
  InputGroup_default as InputGroup,
  InputGroupText_default as InputGroupText,
  Jumbotron_default as Jumbotron,
  Label_default as Label,
  ListGroup_default as ListGroup,
  ListGroupItem_default as ListGroupItem,
  Modal_default as Modal,
  ModalBackdrop_default as ModalBackdrop,
  ModalBody_default as ModalBody,
  ModalFooter_default as ModalFooter,
  ModalHeader_default as ModalHeader,
  Nav_default as Nav,
  NavItem_default as NavItem,
  NavLink_default as NavLink,
  Navbar_default as Navbar,
  NavbarBrand_default as NavbarBrand,
  NavbarToggler_default as NavbarToggler,
  Offcanvas_default as Offcanvas,
  OffcanvasBackdrop_default as OffcanvasBackdrop,
  OffcanvasBody_default as OffcanvasBody,
  OffcanvasHeader_default as OffcanvasHeader,
  Pagination_default as Pagination,
  PaginationItem_default as PaginationItem,
  PaginationLink_default as PaginationLink,
  Popover_default as Popover,
  Portal_default as Portal,
  Progress_default as Progress,
  Row_default as Row,
  Spinner_default as Spinner,
  Styles_default as Styles,
  TabContent_default as TabContent,
  TabPane_default as TabPane,
  Table_default as Table,
  Toast_default as Toast,
  ToastBody_default as ToastBody,
  ToastHeader_default as ToastHeader,
  Tooltip_default as Tooltip
};
//# sourceMappingURL=sveltestrap.js.map
